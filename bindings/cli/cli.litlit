# Motivation

Especially while debugging, testing, or prototyping, the easiest available
interface to interact with a device is often a text-based console. It is
generally easier to spit ASCII across a serial interface than to work with USB,
Bluetooth, Wi-Fi, Ethernet, or any other transmission protocol, both in terms
of setting up the hardware, and connecting to it from a PC. A text-based
console can also be used as a test environment when embedded hardware
processors are not involved. For these reasons, one of the first bindings to be
implemented is (TODO: was) a command line interface.

# Design Reasoning

What we would like to achieve is for the endpoints of a simple processor, or
multiple such processors, e.g. the components of the one-bit bongo described in
another directory of the project, to have their endpoints exposed over a
text-based command line interface. 

## Portability

We would like the code that implements this binding to reflect generically over
the endpoints of the component without having to explicitly name them in source
code, so that the binding can readily adapt to arbitrary components. We would
like the binding to work with minimal repetition when running the component in
a simulated environment, where all input and output come through the command
line, and when running it as a hardware device, where some inputs and outputs
are generated by external hardware events, and where the command line is
physically realized across a serial port interface. Eventually, other
interfaces for command-line interaction are easy to imagine, such as a
web-based command line for advanced debugging.

## Basic Functionality

We would like to be able to query the current value of an endpoint, and set the
value of destination endpoints. For instance, we might issue the command `get
Button-Edge-Detector button-state` and receive the response `true` or `false`.
We could change the button state by issuing the command `set
button-edge-detector button-state true`. For testing and debugging, we would
like to be able to trigger execution of a components's processing, e.g. by
issuing the command `trigger button-edge-detector`.

We would like to be able to query the metadata of a component and its endoints:

```sh
> describe button-gesture-model
inputs:
    button-state: bool
    # etc.
outputs:
    rising-edge: bool
    falling-edge: bool
    any-edge: bool
    # etc.
```

We would like to be able to get a list of all the components that can be
interacted with by the command line interface:

```sh
> list
gpio-pin
button-gesture-model
# etc.
```

And finally, we would like to be able to get a list of all the CLI commands:

```sh
> help
# @='help text'
list
    Get a list of componentss.
describe <component>
    Print the metadata associated with a component
get <component> <endpoint>
    Print the current state of an endpoint
set <component> <endpoint> <value>
    Change the current state of an endpoint
trigger <component>
    Run a component's process
help
    Print a helpful list of commands
# @/
```

## Commands

### Commands as Shell Programs

For maximum portability, it seems likely that a character-by-character approach
will provide the easiest adaptability to different environments. The most obvious
approach to me is to accumulate characters until a full line of input is collected
(or the buffer overflows), and then tokenize that line of input and attempt to
match it to known commands. If a match is found, then control can flow to that
command, passing the whole command line as input to it.

So I am imagining a pipeline roughly like this:

```
accumulate inputs(character)
    buffer[write_position++] = character
    if character == '\n'
        parse line
        write_position = 0
    else if write_position == buffer size
        complain about buffer overflow
        write_position = 0

parse line(line)
    command = get_first_token()
    switch (command)
        execute command with line as input
```

Notice that the commands are effectively self contained programs. In principle,
each command could do almost anything. Given this, we may wish to adopt a familiar
convention for the interface to a command. We can imagine, for instance, the
following abstract base class for all commands:

```c++
struct ShellProgram
{
    virtual int main(int argc, char ** argv) = 0;
};
```

This implies that we are treating our CLI like an OS shell, and our CLI
commands as executable programs. This analogy is a bit strained under the
actual expected environment, where the commands are compiled into the CLI,
which runs as a binding in e.g. the firmware of a digital musical instrument.
This is a far cry from the shell of an OS, where the commands are separately
compiled programs in the path of the shell. For one thing, our `ShellProgram`s
can't reasonably assume that there are any common OS facilities available, like
`printf` or `std::cout`, which would normally be included by a shell program's
source code and dynamically linked to a library on the system.

### Printing Through Ports

With respect to our main target environment (i.e. firmware) and its
constraints, our CLI commands might more reasonably adopt an interface that
acknowledges the requirements we're trying to address. We only need our CLI
commands to interact with the bound components, to parse their command-specific
CLI arguments, and to write text to the text output. We should also try not
to get ahead of ourselves. Our immediate need is a simple CLI for basic
debugging and testing purposes. It would be inappropriate to start building a
general-purpose shell scripting environment at this point. It's tempting to try
to develop a `ShellProgram` API that is independent of this basic CLI, but to
do so would be premature at this time.

At the same time, some of the facilities we develop here may be useful across
other components. Many components, like our CLI commands, may require some way of
outputting errors, error messages, and other text logs. We might consider
treating these as `outputs` in the same way we treat other output signals:

```c++
struct CliCommand
{
    static _consteval auto name() { return "Example Command"; }

    struct outputs_t
    {
        struct stdout_t
        {
            static _consteval auto name() { return "standard text output"; }
            const char * value;
        } stdout;
    } outputs;

    void main(int argc, char ** argv); // return code is now an output port
};
```

The main problem with this approach is that the memory for string-type outputs
needs to be managed somehow, even though in principle there should be no real
need to store whole messages. In an embedded context, bytes can most likely
be sent more or less as needed, and buffering should in any case be handled by
the serial interface's drivers, not the component sending the message. In an
environment with an operating system, the OS should handle buffering of messages.
In general, the component is not well suited to deal with this concern. Particularly
in an embedded context, where it may be inappropriate to use automatically
memory-managed containers from the standard library (e.g. `std::string_stream`
seems obviously relevant), the burden of memory management can be significant.

For simple components with very basic logging needs, e.g. if all messages that may
ever be logged are known at compile time, a string-typed output port may still
be useful. But in case the messages incorporate runtime information, this
approach is probably not satisfactory.

For some commands, generating their entire possible output at compile time is
very likely achievable. However, while this might work well enough in case of a
component running on a PC, where program memory is abundant, the resulting
duplication of strings is likely not tolerable in many embedded systems. For
instance, if the message for the `list` command were statically generated at
compile time, it would result in the duplication of the names of every component
bound to the CLI. This kind of duplication would very likely add up quickly
until it starts to crowd out more important functionality.

### Printing Through Feature Injection

What is needed is a way to pass in a function that can accept a string and
immediately print it or buffer it for printing with the appropriate driver. In
the current version of [Avendish](github.com/celtera/avendish) at the time of
writing, this is accomplished through a dependency injection mechanism where
the component or command in need of logging functionality accepts a template parameter that
provides a logger. This seems like possibly the only reasonable approach.
Effectively, the only way to explicitly pass the thread of execution from one
place to another is through a function call. So here are some of the options

- the component author includes the function(s) for printing
- the component user inherits from the component and overrides its virtual printing method(s)
- the component accepts a callback function pointer or pointer to class that is called on for printing
- the printing function or class is passed as a template parameter to the component

In all cases, the component author and binding author are forced to agree on a
convention for the printing calls. There's no getting around that. In the first
case, the hardware specific printer is determined at link time; we would prefer
to make this choice explicit in source code. In the second case, an abundance
of near-identical subclassing is likely to abound, as the binding author
subclasses every component to work with every feature that needs to be
injected--quadratic glue code in other words, and we are not willing to accept
that. A class pointer could work; the component author would include an abstract
base class, and then the binding author can provide subclasses for each
hardware specific driver. There's no glue code, but this approach inextricably
links the component implementation to that abstract base, which becomes pulled in
as an explicit physical dependency of the component. This is a level of
frameworkization that we would prefer to avoid. A function callback could work,
except it would require the component author to match all material for printing to
one function call signature, e.g. `void (*print)(char * str)`. This means that
the responsibility for converting any data that needs to be printed into a
`char * str` falls on the component author. We would prefer for them to be able to
focus on writing their component without having to think about string formatting
conversions.

All that's left (unless I've forgotten something) is the template parameter.
This is only very slightly better than a pointer to a class. In both cases, the
component author admits a dependency on the call signature requirements of the
printer. The template parameter option has these main advantages: the
dependency is implicit, meaning that it is simpler for binding authors to meet
the requirements without modifying the component's implementation, and the component
and binding implementations aren't required to share any source code; the
injection of the feature imposes no runtime cost, since the full signature of
the printer and component are both known at compile time, so there's no
indirection through a base class; compile time injection also enables stronger
type checking, and potentially allows the binding author to enable optimization
through compile-time programming and template metaprogramming, if applicable.
The cost is likely in compilation time, since the component code has to be
recompiled for every different printer. However, in this context that cost is
negligible, since we're already committed to recompiling our components for each
new binding.

The design of the printer is sufficiently involved that it is addressed in
its own directory.

### Summary

So we have moved from considering our CLI commands as general purpose shell
programs, to restricting that view to see them as mere text outputters, to once
again broadening our view to see them as general purpose
reflectable-aggregate-type components with textual output ports, to recognizing
that text output requires feature injection, preferably through a template
parameter, to avoid glue code, forcing explicit dependencies on the component, and
added runtime costs. This leads to the following plan, demonstrated with a
simple `echo` command, for the commands' general interface, borrowing the
conceptual design of the logger feature injection scheme from Avendish:

```c++
// @+'test commands'
template<typename Config>
struct Echo
{
    static _consteval auto name() { return "echo"; }
    static _consteval auto description() { return "Repeats its arguments, separated by spaces, to the output"; }

    [[no_unique_address]] typename Config::basic_logger_type log; 

    template<typename ... Components>
    int main(int argc, char ** argv, std::tuple<Components...>&)
    {
        for (int i = 1; i < argc; ++i)
        {
            log.print(argv[i]);
            if (i + 1 < argc) log.print(" ");
        }
        log.println();
        return 0;
    };
};
// @/
```

# CLI

As described above, the CLI provides a fairly limited amount of behavior. It's
main role is to simply accumulate inputs until a full line is available,
try to match the first token in the line to a command, and execute it if a match
is found.

## Tests

We'll define a function to facilitate testing, inspired by chatGPT's failed
attempt to generate tests for me, that accepts a string as input to the CLI and
returns a string representing whatever the CLI prints in response. We also
define some test components and a configuration.

```c++
// @='cli test wrapper'
template <typename Cli>
string cli_process_input(Cli& cli, string input)
{
    cli.log.put.ss.str("");
    for (char c : input)
        cli.process(c);
    return cli.log.put.ss.str();
}
// @/

// @='test components'
struct Component1 {
    static _consteval auto name() { return "Test Component 1"; }
};

struct Component2 {
    static _consteval auto name() { return "Test Component 2"; }
};
// @/

// @='test config class'
struct Config
{
    using basic_logger_type = sygaldry::bindings::basic_logger::TestLogger;
};
// @/

```

We can then test the CLI using a few trivial commands, such as the `echo` command
defined above, and the following:

```c++
// @+'test commands'
template<typename Config>
struct HelloWorld
{
    static _consteval auto name() { return "hello"; }
    static _consteval auto description() { return "Say's 'Hello world!' Useful for testing the CLI"; }

    [[no_unique_address]] typename Config::basic_logger_type log; 

    template<typename ... Components>
    int main(int argc, char ** argv, std::tuple<Components...>&)
    {
        log.println("Hello world!");
        return 0;
    };
};
// @/

// @+'tests'
TEST_CASE("CLI", "[bindings][cli]")
{
    auto components = std::make_shared<std::tuple<Component1, Component2>>();
    auto cli = make_cli<Config, Echo, HelloWorld>(components);

    @{cli tests}
    SECTION("Hello world")
    {
        REQUIRE(cli_process_input(cli, "hello\n") == "Hello world!\n> ");
    }

    SECTION("Echo")
    {
        REQUIRE(cli_process_input(cli, "echo foo bar baz\n") == "foo bar baz\n> ");
    }
}
// @/
```

## Implementation

### Buffers

We'll statically allocate some buffers as class member variables to hold the
incoming characters, a count of tokens found, and pointers to the beginnings
of the tokens. For now, the size of the buffers is determined heuristically.
Ideally we should iterate over the commands at compile time and determine
exactly how big these buffers need to be, but this is left as future work
for now:

```c++
// @='cli buffers'
static constexpr size_t MAX_ARGS = 5;
static constexpr size_t BUFFER_SIZE = 128;
int argc = 0;
char * argv[MAX_ARGS];
unsigned char write_pos = 0;
char buffer[BUFFER_SIZE];
// @/
```

### Process loop

With these resources, we can outline the process function. The plan is to
keep track of the onset of arguments in `argv`, and to convert whitespace
to null characters so that the arguments are automatically null terminated.

At the end of each line, we pass the first token and our list of commands to
the `dispatch` subroutine defined in `bindings/name_dispatch.hpp`. If it
returns a non-zero error code, we print a message. Then, regardless of the
command's exit status, we reset the buffers, print a new prompt, and return to
the normal process loop. The same reset routine is called if our input buffer
overflows.

```c++
// @='cli process'
if (_is_whitespace(c))
    buffer[write_pos++] = 0;
else
{
    buffer[write_pos] = c;
    if (_new_arg())
        argv[argc++] = &buffer[write_pos];
    write_pos++;
}

if (c == '\n')
{
    auto retcode = _try_to_match_and_execute();
    if (retcode != 0) _complain_about_command_failure(retcode);
    _reset();
}

if (_overflow())
{
    log.println("CLI line buffer overflow!");
    _reset();
}
// @/
```

We invoke the matcher subroutine as follows, accounting for `help`
as a special case in our callback lambda, and using a kebab-case
respeller in our matcher.

```c++
// @+'cli implementation details'
struct CommandMatcher
{
    template<typename stringish, typename Command>
    bool operator()(stringish arg0, const Command& command)
    {
        using spelling::lower_kebab_case;
        return std::string_view(arg0) == std::string_view(lower_kebab_case(command));
    }
};

int _try_to_match_and_execute()
{
    return dispatch<CommandMatcher>(argv[0], commands, 127, [this](auto& command)
        {
            if constexpr (std::is_same_v<decltype(command), commands::Help<Config>&>)
            {
                return std::apply([&]<typename ... Cmds>(Cmds&& ... cmds)
                {
                    return command.main(cmds...);
                }, commands);
            }
            else return command.main(argc, argv, *components);
        });
}
// @/
```

### Instantiation

The CLI is a template that can accept an arbitrary number of components and
commands, and requires a configuration that is passed through to all
of its commands. Being able to instantiate such a template without having to name
all of the components and commands twice (e.g. in the template argument list
and the constructor) is essential.

We require the components to be wrapped in a
`std::shared_ptr<std::tuple<Components...>>`; we assume that the client of the CLI
will have already made such a container for the components that they can pass to
the CLI constructor, and we insist that the user not have to name the list of
`Components...` when instantiating the CLI. We further assume that the list of
commands will, by default, be all available commands, but that (particularly
for testing) some clients will want to specify their own list of commands.

Unfortunately, we cannot rely on class template argument deduction (CTAD) to
help us here, because the client will always need to specify the CLI `Config`
type as a template argument, e.g. `auto cli = CLI<Config>(components,
arguments...);`. CTAD is not attempted when a template argument is explicitly
given, so this won't ever work. We would have to explicitly state all template
arguments, e.g. `auto cli = CLI<Config, std::shared_ptr<std::tuple<Cpt1, Cpt2,
..., CptN>>, Cmd1, Cmd2, ..., CmdN>(components, arguments...);` which is not
acceptable. For the same reason, we cannot simply provide a template type
alias to specify the default list of commands.

The solution comes from defining factory functions for instantiating a CLI.
Template function argument deduction can tolerate partial specification of the
template parameters, so in this way we can have a function that takes a config
and list of commands and deduces the components from the argument, and another
than takes only a config, deduces the components, and uses the default set of all
available commands. Unfortunately we must provide two seperate functions; since
the arguments must be the same, overloading the same function would result in
ambiguity that the compiler cannot resolve.

```c++
// @='cli default type alias'
template<typename Config, template<typename>typename ... Commands, typename ... Cpts>
auto make_cli(std::shared_ptr<std::tuple<Cpts...>> cpts, const char * boot_message = "")
{
    return Cli<Config, std::shared_ptr<std::tuple<Cpts...>>, commands::Help, Commands...>(cpts, boot_message);
}

template<typename Config, typename ... Cpts>
auto make_default_cli(std::shared_ptr<std::tuple<Cpts...>> cpts, const char * boot_message = "")
{
    return Cli<Config, std::shared_ptr<std::tuple<Cpts...>>, commands::Help
            , commands::@{default commands}
            >(cpts, boot_message);
}
// @/
```

The constructor simply copies the pointer to the components, writes a welcome
message, and then prompts the user for input. The logger specified by the
configuration and a tuple of commands with the same configuration are both
default initialized.

```c++
// @='cli instantiation'
[[no_unique_address]] typename Config::basic_logger_type log{};
std::tuple<Commands<Config>...> commands{};
cpts_t components;

Cli(cpts_t cpts, const char * extra_boot_message)
: components{cpts}
{
    log.println("CLI enabled. Write `help` for a list of available commands.");
    if (extra_boot_message[0] != '\0') log.println(extra_boot_message);
    _prompt();
}
// @/

### Details

```c++
// @+'cli implementation details'
bool _is_whitespace(char c)
{
    if (c == ' ' || c == '\t' || c == '\n') return true;
    else return false;
}

bool _new_arg() const
{
    return write_pos == 0 || buffer[write_pos-1] == 0;
}

bool _overflow() const
{
    return argc == MAX_ARGS || write_pos == BUFFER_SIZE;
}

void _prompt()
{
    log.print("> ");
}

void _reset()
{
    argc = 0;
    write_pos = 0;
    _prompt();
}

void _complain_about_command_failure(int retcode)
{} // TODO
// @/

### Summary

```c++
// @#'cli.hpp'
#pragma once
#include <memory>
#include <tuple>
#include <string_view>
#include "utilities/consteval.hpp"
#include "bindings/name_dispatch.hpp"
@{commands headers}

namespace sygaldry { namespace bindings::cli
{

template<typename Config, typename cpts_t, template<typename> typename ... Commands>
struct Cli
{
    @{cli instantiation}

    @{cli buffers}

    @{cli implementation details}

    void process(char c)
    {
        @{cli process}
    }
};

@{cli default type alias}

} }
// @/
```

# First Commands: `list` and `help`

Recalling our earlier discussion of the basic functionality we require, two
commands, `list` and `help` stand out as particularly simple, since they don't
need to actually interact much with the components.

## List Command

The list command should output a new-line separated list of component names:

```c++
// @+'tests'
TEST_CASE("List command outputs", "[cli][commands][list]")
{
    int argc = 1;
    char * arg = (char *)"list";
    char ** argv = &arg;

    List<Config> command;

    auto components = std::make_tuple(Component1{}, Component2{});
    command.log.put.ss.str("");
    auto retcode = command.main(argc, argv, components);

    REQUIRE(command.log.put.ss.str() == string("test-component-1\ntest-component-2\n"));
    REQUIRE(retcode == 0);
}
// @/
```

Notice that we expect the component names to be converted to lower-kebab-case,
since this is arguably the most idiomatic spelling for a CLI context, and
easier to parse than a natural spelling with spaces.

Since component names are `_consteval`, we can generate the whole expected output
at compile time. However, doing so is noticeably more complicated than merely
printing the correct output at runtime, and also imposes an increased program
size to statically store the generated strings, which needlessly duplicates the
names of components. Instead, we'll iterate over the component types using a fold
expression and print each one's name using the injected logger.

```c++
// @#'commands/list.hpp'
#pragma once

#include "utilities/consteval.hpp"
#include "utilities/spelling.hpp"

namespace sygaldry
{
namespace bindings::cli::commands
{

template<typename Config>
struct List
{
    static _consteval auto name() { return "list"; }
    static _consteval auto usage() { return ""; }
    static _consteval auto description() { return "List the components available to interact with through the CLI"; }

    [[no_unique_address]] typename Config::basic_logger_type log;

    template<typename... Components>
    int main(int argc, char** argv, std::tuple<Components...>&)
    {
        ( log.println(spelling::lower_kebab_case_v<Components>), ... );
        return 0;
    }
};

}
}
// @/

// @+'commands headers'
#include "commands/list.hpp"
// @/

// @+'default commands'
List
// @/
```

## Help Command

The help command is a bit unusual, since it actually doesn't care about
components, but rather commands. It should print each command's name, usage, and a
brief description. The name is easy enough, as is the description, since it's
reasonable to expect the command to provide both of these considering there's
no reasonable way to deduce them. It would be ideal if the usage text could be
derived by reflecting on the command, but enabling this would require us to
make assumptions about the way commands are shaped, since it's not possible to
deduce anything from the signature `int main(argc, argc, components)`. For now,
we'll take the easiest route and require commands to provide their usage text
if the command takes arguments.

```c++
// @+'test commands'
struct Command1 {
    static _consteval auto name() { return "test-command-1"; }
    static _consteval auto usage() { return "foo bar"; }
    static _consteval auto description() { return "Description 1"; }
};

struct Command2 {
    static _consteval auto name() { return "test-command-2"; }
    // no arguments, no usage text
    static _consteval auto description() { return "Description 2"; }
};
// @/

// @+'tests'
TEST_CASE("Help command", "[cli][commands][help]")
{
    Help<Config> command;

    command.log.put.ss.str("");
    auto retcode = command.main(Command1{}, Command2{});

    REQUIRE(command.log.put.ss.str() == string("test-command-1 foo bar\n    Description 1\ntest-command-2\n    Description 2\nhelp\n    Describe the available commands and their usage\n"));
    REQUIRE(retcode == 0);
}
// @/
```

Since the help command is a special case, which operates over commands instead
of components, we allow it to buck the pattern established with the list command
and have a `main` method that takes a parameter pack of commands to describe.

```c++
// @#'commands/help.hpp'
#pragma once
#include "utilities/consteval.hpp"

namespace sygaldry
{
namespace bindings::cli::commands
{
template<typename Config>
struct Help
{
    static _consteval auto name() { return "help"; }
    static _consteval auto usage() { return ""; }
    static _consteval auto description() { return "Describe the available commands and their usage"; }

    [[no_unique_address]] typename Config::basic_logger_type log;

    template<typename Cmd>
    void _print(Cmd&& command)
    {
        if constexpr (requires {command.usage();})
            log.println(command.name(), " ", command.usage());
        else
            log.println(command.name());
        log.println("    ", command.description());
    }

    template<typename ... Commands>
    int main(Commands&& ... commands)
    {
        ( _print(commands), ... );
        log.println(name());
        log.println("    ", description());
        return 0;
    }
};

}
}
// @/

// @+'commands headers'
#include "commands/help.hpp"
// @/
```

Unlike with the list command, we don't append the help command to our
code chunk for default commands; instead it is explicitly added by the
factory methods described above so that it is always available even
when the user does not use the default commands.

# Component Commands

These commands all take the name of a component as their first argument, and
`describe`, `get`, and `set` additionally take the name of a port of that
component. Here we see a possible disadvantage of the compile-time approach
to generic code. As opposed to run-time polymorphism, where at some levels
the same binary code can be used to perform the same subroutine, unique but
very similar machine code may be generated for the branch of code that acts
on the matched component and/or port names, each command because
our commands and components are all unique types. It remains to be seen whether
this leads to a problematic increase in compiled binary code size. If it
ever becomes an issue, it may be helpful to exploit runtime polymorphism when
matching command, component, and port names. However, it is likely not possible
to reduce the steps necessary to iterate over the heterogeneous endpoints of
different components. They are simply not the same.

## Describe

First, a test case, using the test component provided in
`components/tests/testcomponent.hpp`:

```c++
// @+'tests'
TEST_CASE("Descibe", "[bindings][cli][commands][describe]")
{
    int argc = 3;
    char * arg0 = (char *)"describe";
    char * arg1 = (char *)"test-component-1";
    char * arg2 = (char *)"slider-out";
    char * argv[] = {arg0, arg1, arg2};
    auto components = std::make_tuple(sygaldry::components::TestComponent{});


    argc = 2;
    SECTION("describe device")
    {
        Describe<Config> command;
        command.log.put.ss.str("");
        auto retcode = command.main(argc, argv, components);
        REQUIRE(command.log.put.ss.str() == string(
R"DESCRIBEDEVICE(component: test-component-1
  name: "Test Component 1"
  type:  component
  input:   button-in
    name: "button in"
    type:  occasional value
    range: false to true (init: false)
  input:   toggle-in
    name: "toggle in"
    type:  persistent value
    range: false to true (init: false)
  input:   slider-in
    name: "slider in"
    type:  persistent value
    range: 0 to 1 (init: 0)
  input:   bang-in
    name: "bang in"
    type:  persistent value
  output:  button-out
    name: "button out"
    type:  occasional value
    range: false to true (init: false)
  output:  toggle-out
    name: "toggle out"
    type:  persistent value
    range: false to true (init: false)
  output:  slider-out
    name: "slider out"
    type:  persistent value
    range: 0 to 1 (init: 0)
  output:  bang-out
    name: "bang out"
    type:  persistent value
)DESCRIBEDEVICE"));
        REQUIRE(retcode == 0);
        command.log.put.ss.str("");
    }

    argc = 3;
    SECTION("describe endpoint")
    {
        Describe<Config> command;
        command.log.put.ss.str("");
        auto retcode = command.main(argc, argv, components);
        REQUIRE(command.log.put.ss.str() == string(
R"DESCRIBEENDPOINT(endpoint: slider-out
  name: "slider out"
  type:  persistent value
  range: 0 to 1 (init: 0)
)DESCRIBEENDPOINT"));

        REQUIRE(retcode == 0);
        command.log.put.ss.str("");
    }
}
// @/
```

The bulk of this command's logic comes from four functions: one that matches an
argument to a component, one that decribes a matched component, one that matches an
argument to an endpoint, and one that describes a matched endpoint. The same matcher
serves for both components and endpoints.

```c++
// @='describe matcher'
struct DescribeMatcher
{
    template<typename stringish, typename Entity>
    bool operator()(stringish name, const Entity& entity)
    {
        using spelling::lower_kebab_case;
        return std::string_view(name) == std::string_view(lower_kebab_case(entity));
    }
};
// @/
```


```c++
// @='describe main'
if (argc < 2) return 2;
bool describe_component = argc == 2;
bool describe_endpoint = argc > 2;
return dispatch<DescribeMatcher>(argv[1], components, 2, [&](auto& component)
{
    if (describe_component)
    {
        describe_entity("component: ", component);
        return 0;
    }
    else if (describe_endpoint) return dispatch<DescribeMatcher>(argv[2], component, 2, [&](auto& endpoint)
    {
        describe_entity("endpoint: ", endpoint);
        return 0;
    });
    else return 0;
});
// @/
```

We generically describe both components and endpoints using the same
methods, which reflect on the input entity using concepts, recursing
over nested entities.

```c++
// @+'describe implementation details'
void describe_entity_type(auto& entity)
{
    using T = decltype(entity);
    if constexpr (Component<T>) log.println("component");
    else if constexpr (PersistentValue<T>) log.println("persistent value");
    else if constexpr (OccasionalValue<T>) log.println("occasional value");
    else if constexpr (Bang<T>) log.println("bang");
    else if constexpr (ClearableFlag<T>) log.println("clearable flag");
    else if constexpr (value_like<T>) log.println("value-like");
}

void describe_entity(auto preface, auto& entity, auto ... indents)
{
    using spelling::lower_kebab_case;
    using T = decltype(entity);
    static_assert(Named<T>);
    log.println(indents..., preface, (const char *)lower_kebab_case(entity));
    log.println(indents..., "  name: \"", entity.name(), "\"");
    log.print(indents...,   "  type:  ");
    describe_entity_type(entity);
    if constexpr (Ranged<T>)
    {
        log.print(indents..., "  range: ");
        auto range = get_range<T>();
        log.println(range.min, " to ", range.max, " (init: ", range.init, ")");
    }
    if constexpr (Component<T>)
    {
        auto describe_group = [&](auto& group, auto groupname)
        {
            boost::pfr::for_each_field(group, [&](auto& entity)
            {
                describe_entity(groupname, entity, "  ", indents...);
            });
        };
        describe_group(entity.inputs,  "input:   ");
        describe_group(entity.outputs, "output:  ");
    }
}
// @/

```c++
// @#'commands/describe.hpp'
#pragma once

#include <boost/pfr.hpp>
#include "utilities/consteval.hpp"
#include "utilities/spelling.hpp"
#include "components/concepts.hpp"
#include "bindings/name_dispatch.hpp"

namespace sygaldry { namespace bindings { namespace cli { namespace commands {

using namespace sygaldry::concepts;

template<typename Config>
struct Describe
{
    static _consteval auto name() { return "describe"; }
    static _consteval auto usage() { return "component-name [endpoint-name]"; }
    static _consteval auto description() { return "Convey metadata about a component or its endpoint. Pass * to describe all"; }

    [[no_unique_address]] typename Config::basic_logger_type log;

    @{describe matcher}

    @{describe implementation details}

    template<typename... Components>
    int main(int argc, char** argv, std::tuple<Components...>& components)
    {
        @{describe main}
    }
};

} } } } // namespaces
// @/
```

// @+'commands headers'
#include "commands/describe.hpp"
// @/

## Get

## Set

## Trigger

# Using the CLI

## Stdio App

For quick tests and experimentation, we would like to be able to run this as an
interactive command line application in the OS of our choice, allowing us to
run our components in a simulated environment, feed them test inputs, and examine
their outputs. The same implementation should also be usable on any environment
that provides `getchar` and `putchar` from the C standard library.

```c++
// @#'cli_app.hpp'
#pragma once
#include "bindings/basic_logger/standard_logger.hpp"
#include "cli.hpp"
#include <stdio.h>
#include <cstdlib>
#include <memory>

struct Config
{
    using basic_logger_type = sygaldry::bindings::basic_logger::StandardLogger;
};

template<typename ... Components>
struct CliApp
{
    int main()
    {
        auto components = std::make_shared<std::tuple<Components...>>();
        auto cli = sygaldry::bindings::cli::make_default_cli<Config>(components, "Type Ctrl-D to exit.");
        for (;;)
        {
            char c = getchar();
            if (c == EOF)
                std::exit(EXIT_SUCCESS);
            else
                cli.process(c);
        }
    }
};
// @/
```

The CLI class itself implements a fairly limited behavior.

```c++
// @#'cli_app_demo.cpp'
#include "cli_app.hpp"
#include "utilities/consteval.hpp"
#include "components/sensors/button/gesture_model.hpp"

struct Component1 {
    static _consteval auto name() { return "Test Component 1"; }
};

struct Component2 {
    static _consteval auto name() { return "Test Component 2"; }
};

int main()
{
    using namespace sygaldry::components;
    CliApp<Component1, Component2, ButtonGestureModel> app{};
    app.main();
}
// @/
```

# Summary

# Building Tests

```c++
// @#'tests.cpp'
#include <string>
#include <catch2/catch_test_macros.hpp>
#include "utilities/consteval.hpp"
#include "components/tests/testcomponent.hpp"
#include "bindings/basic_logger/test_logger.hpp"
#include "cli.hpp"

using std::string;

using namespace sygaldry::bindings::cli::commands;
using namespace sygaldry::bindings::cli;

@{cli test wrapper}

@{test commands}

@{test components}

@{test config class}

@{tests}
// @/
```

```cmake
# @#'CMakeLists.txt'
add_executable(cli-tests tests.cpp)
target_link_libraries(cli-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(cli-tests)

add_executable(cli-demo cli_app_demo.cpp)
# @/
```
