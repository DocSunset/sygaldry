# Motivation

Especially while debugging, testing, or prototyping, the easiest available
interface to interact with a device is often a text-based console. It is
generally easier to spit ASCII across a serial interface than to work with USB,
Bluetooth, Wi-Fi, Ethernet, or any other transmission protocol. A text-based
console can also be used as a test environment when embedded hardware
processors are not involved. For these reasons, one of the first bindings
to be implemented is (TODO: was) a command line interface.

# Overview

What we would like to achieve is for the endpoints of a simple processor, e.g.
the one-bit bongo described in another directory of the project, to have its
endpoints exposed over a text-based command line interface. 

## Portability

We would like the code that implements this binding to reflect generically over
the endpoints of the device without having to explicitly name them in source
code, so that it can readily adapt to arbitrary processors. We would like the
binding to work with minimal repetition when running the processor in a
simulated environment, where all input and output come through the command
line, and when running it as a hardware device, where some inputs and outputs
are generated by external hardware events, and where the command line is
physically realized across a serial port interface. Eventually, other
interfaces for command-line interaction are easy to imagine, such as a
web-based command line for advanced debugging.

## Basic Functionality

We would like to be able to query the current value of an endpoint, and set the
value of destination endpoints. For instance, we might issue the command `get
Button-Edge-Detector button-state` and receive the response `true` or `false`.
We could change the button state by issuing the command `set
Button-Edge-Detector button-state true`. For testing and debugging, we would
like to be able to trigger execution of a device's processing, e.g. by
issuing the command `trigger Button-Edge-Detector`.

We would like to be able to query the metadata of a device and its endoints:

```sh
> describe Button-Gesture-Model
inputs:
    button-state: bool
    # etc.
outputs:
    rising-edge: bool
    falling-edge: bool
    any-edge: bool
    # etc.
```

We would like to be able to get a list of all the devices that can be
interacted with by the command line interface:

```sh
> list
GPIO-Pin
Button-Gesture-Model
# etc.
```

And finally, we would like to be able to get a list of all the CLI commands:

``sh
> help
# @='help text'
list
    Get a list of devices.
describe <device>
    Print the metadata associated with a device
get <device> <endpoint>
    Print the current state of an endpoint
set <device> <endpoint> <value>
    Change the current state of an endpoint
trigger <device>
    Run a device's process
help
    Print a helpful list of commands
# @/
```

@#'CMakeLists.txt'
# nothing yet...
@/
