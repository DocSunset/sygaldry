# Motivation

Especially while debugging, testing, or prototyping, the easiest available
interface to interact with a device is often a text-based console. It is
generally easier to spit ASCII across a serial interface than to work with USB,
Bluetooth, Wi-Fi, Ethernet, or any other transmission protocol, both in terms
of setting up the hardware, and connecting to it from a PC. A text-based
console can also be used as a test environment when embedded hardware
processors are not involved. For these reasons, one of the first bindings to be
implemented is (TODO: was) a command line interface.

# Overview

What we would like to achieve is for the endpoints of a simple processor, or
multiple such processors, e.g. the components of the one-bit bongo described in
another directory of the project, to have their endpoints exposed over a
text-based command line interface. 

## Portability

We would like the code that implements this binding to reflect generically over
the endpoints of the device without having to explicitly name them in source
code, so that the binding can readily adapt to arbitrary processors. We would
like the binding to work with minimal repetition when running the processor in
a simulated environment, where all input and output come through the command
line, and when running it as a hardware device, where some inputs and outputs
are generated by external hardware events, and where the command line is
physically realized across a serial port interface. Eventually, other
interfaces for command-line interaction are easy to imagine, such as a
web-based command line for advanced debugging.

# Design Reasoning

## Basic Functionality

We would like to be able to query the current value of an endpoint, and set the
value of destination endpoints. For instance, we might issue the command `get
Button-Edge-Detector button-state` and receive the response `true` or `false`.
We could change the button state by issuing the command `set
Button-Edge-Detector button-state true`. For testing and debugging, we would
like to be able to trigger execution of a device's processing, e.g. by
issuing the command `trigger Button-Edge-Detector`.

We would like to be able to query the metadata of a device and its endoints:

```sh
> describe Button-Gesture-Model
inputs:
    button-state: bool
    # etc.
outputs:
    rising-edge: bool
    falling-edge: bool
    any-edge: bool
    # etc.
```

We would like to be able to get a list of all the devices that can be
interacted with by the command line interface:

```sh
> list
GPIO-Pin
Button-Gesture-Model
# etc.
```

And finally, we would like to be able to get a list of all the CLI commands:

```sh
> help
# @='help text'
list
    Get a list of devices.
describe <device>
    Print the metadata associated with a device
get <device> <endpoint>
    Print the current state of an endpoint
set <device> <endpoint> <value>
    Change the current state of an endpoint
trigger <device>
    Run a device's process
help
    Print a helpful list of commands
# @/
```

## Command API

For maximum portability, it seems likely that a character-by-character approach
will provide the easiest adaptability to different environments. The most obvious
approach to me is to accumulate characters until a full line of input is collected
(or the buffer overflows), and then tokenize that line of input and attempt to
match it to known commands. If a match is found, then control can flow to that
command, passing the whole command line as input to it.

So I am imagining a pipeline roughly like this:

```
accumulate inputs(character)
    buffer[write_position++] = character
    if character == '\n'
        parse line
        write_position = 0
    else if write_position == buffer size
        complain about buffer overflow
        write_position = 0

parse line(line)
    command = get_first_token()
    switch (command)
        execute command with line as input
```

Notice that the commands are effectively self contained programs. In principle,
each command could do almost anything. Given this, we may wish to adopt a familiar
convention for the interface to a command. We can imagine, for instance, the
following abstract base class for all commands:

```c++
struct ShellProgram
{
    virtual int main(int argc, char ** argv) = 0;
};
```

This implies that we are treating our CLI like an OS shell, and our CLI
commands as executable programs. This analogy is a bit strained under the
actual expected environment, where the commands are compiled into the CLI,
which runs as a binding in the firmware of a digital musical instrument. This
is a far cry from the shell of an OS, where the commands are separately
compiled programs in the path of the shell. For one thing, our `ShellProgram`s
can't reasonably assume that there are any common OS facilities available, like
`printf` or `std::cout`, which would normally be included by a shell program's
source code and linked to a static library on the system.

With respect to our main target environment (i.e. firmware) and its
constraints, our CLI commands might more reasonably adopt an interface that
acknowledges the requirements we're trying to address. We only need our CLI
commands to interact with the bound devices, to parse their command-specific
CLI arguments, and to write text to the serial output. We should also try not
to get ahead of ourselves. Our immediate need is a simple CLI for basic
debugging and testing purposes. It would be inappropriate to start building a
general-purpose shell scripting environment at this point. It's tempting to
try to develop a `ShellProgram` API that is independent of this basic CLI,
but to do so would be premature at this time.

At the same time, some of the facilities we develop here may be useful across
other devices. Many devices, like our CLI commands, may require some way of
outputting errors, error messages, and other text logs. We might consider
treating these as `outputs` in the same way we treat other output signals:

```c++
struct CliCommand
{
    static consteval auto name() { return "Example Command"; }

    struct outputs_t
    {
        struct stdout_t
        {
            static consteval auto name() { return "standard text output"; }
            const char * value;
        } stdout;

        struct return_code_t
        {
            static consteval auto name() { return "return code"; }
            int value;
        } retcode;
    } outputs;

    void main(int argc, char ** argv); // return code is now an output port
};
```

The main limitation of this approach is that only one `char *` or `int`
can be output for every call to `main`, or `process`, or whatever the
device's main execution method is called. As this isn't really a problem
in the context of our CLI, we'll suppose that it may not be a problem
for devices, and carry on this this strategy for now.

So we have moved from considering our CLI commands as general purpose shell
programs, to restricting that view to see them as mere text outputters, to once
again broadening our view to see them as general purpose
reflectable-aggregate-type devices with textual output ports. One last
restriction of our perspective should do to bring our CLI commands' conceptual
modelling in line with their requirements, which is to require them to act as
bindings over devices:

```c++
template<typename ... Devices>
struct CliCommand
{
    // ...

    int main(int argc, char ** argv, std::tuple<Devices...>& devices);
};
```

Our CLI is then constructed from a list of `CliCommand`s and devices,
perhaps roughly resembling the following::

```c++
template<typename ... Commands, typename ... Devices>
class CLI
{
    std::shared_ptr<std::tuple<Devices...>> devices;
    CLI(std::shared_ptr<std::tuple<Devices...>> devs) : devices{devs} {};

    struct outputs_t
    {
        struct stdout_t
        {
            static consteval auto name() { return "standard text output"; }
            const char * value;
        } stdout;

        struct return_code_t
        {
            static consteval auto name() { return "return code"; }
            int value;
        } retcode;
    } outputs;

    int argc;
    char * argv[MAX_ARGS];
    char buffer[BUFFER_SIZE];
    size_t buffer_write_position;

    static bool _is_whitespace(char c)
    {
        if (c == ' ' || c == '\t' || c == '\n') return true;
        else return false;
    }

    bool _new_arg() const
    {
        return buffer_write_position == 0 || buffer[buffer_write_position-1] == 0;
    }

    bool _overflow() const
    {
        return argc == MAX_ARGS || buffer_write_position == BUFFER_SIZE;
    }

    void process(char c)
    {
        if (_is_whitespace(c))
            buffer[buffer_write_position] = 0; // ignore whitespace
        else
        {
            buffer[buffer_write_position] = c;
            if (_new_arg())
            {
                argv[argc] = &buffer[buffer_write_position];
                argc++;
            }
            buffer_write_position++;
        }
        if (c == '\n')
            _match_and_execute_command<Commands ...>(argv[0]);
        if (c == '\n' || _overflow())
        {
            argc = 0;
            buffer_write_position = 0;
        }
    }

    template <typename Command, typename ... Cmds>
    void _match_and_execute_command(const char * command_name) const
    {
        if (std::string_view(command_name) == std::string_view(Command::name()))
        {
            auto matched_command = Command<Devices...>{};
            matched_command.main(argc+1, argv, *devices);
            outputs.stdout.value = matched_command.outputs.stdout.value;
            outputs.retcode.value = matched_command.outputs.retcode.value;
        }
        else if constexpr (sizeof...(Cmds) == 0)
        {
            outputs.stdout.value = nullptr;
            outputs.retcode.value = 127;
        }
        else
        {
            _match_and_execute_command<Cmds...>(command_name);
        }
    }
}
```

# First Steps: `list` and `help`

Recalling our earlier discussion of the basic functionality we require, two
commands, `list` and `help` stand out as particularly simple, since they don't
need to actually interact much with the devices.

## List Command

The list command should output a new-line separated list of device names.

### Tests

```c++
// test cases initially generated by chatGPT

// @='test devices'
struct Device1 {
    static consteval auto name() { return "Test Device 1"; }
};

struct Device2 {
    static consteval auto name() { return "Test Device 2"; }
};
// @/

// @+'tests'
TEST_CASE("List command outputs", "[cli][commands][list]")
{
    int argc = 1;
    char * arg = (char *)"list";
    char ** argv = &arg;

    List<Device1, Device2> command;

    auto devices = std::make_tuple(Device1{}, Device2{});
    command.main(argc, argv, devices);

    REQUIRE(detail::list_output_length_v<Device1, Device2> == 29);
    REQUIRE(string(command.outputs.stdout.value) == string("test-device-1\ntest-device-2\n"));
    REQUIRE(command.outputs.retcode.value == 0);
}
// @/
```

Notice that we expect the device names to be converted to lower-kebab-case,
since this is arguably the most idiomatic spelling for a CLI context, and
easier to parse than a natural spelling with spaces.

### Implementation

Since device names are `consteval`, we can generate the whole expected output
at compile time. We can calculate the overall length of the output list as the
sum for each device of the length of its name plus one for a newline, with an
extra one added for the null terminator at the end of the string:

```c++
// @='list output length'
using utilities::metadata::names::name_length;

template<typename ... Devices>
struct list_output_length
{
    static constexpr size_t value = 1;
};

template<typename Device, typename ... Devices>
struct list_output_length<Device, Devices...>
{
    static constexpr size_t value = name_length<Device>() + 1
        + list_output_length<Devices...>::value;
};

template<typename ... Devices>
constexpr size_t list_output_length_v = list_output_length<Devices...>::value;
// @/
```

With that, we can statically allocate an array for the string, and copy the
names of the devices into it at compile time. This requires the use of a lambda
and a fold expression over the comma operator to iterate over the device types:

```c++
// @='generate output for list command'
namespace detail
{
@{list output length}

using utilities::metadata::names::lower_kebab_case_v;

template<typename ... Devices>
struct list
{
    static constexpr size_t N = list_output_length_v<Devices...>;
    static constexpr std::array<char, N> value = []()
    {
        std::array<char, N> ret{};
        size_t offset = 0;

        ret[N-1] = '\0';

        auto copy_one_name =  [&]<typename Device>(Device)
        {
            constexpr auto I = name_length<Device>();
            for (size_t i = 0; i < I; ++i)
            {
                ret[i + offset] = lower_kebab_case_v<Device>[i];
            }
            ret[I + offset] = '\n';
            offset += I+1;
        };

        (copy_one_name(Devices{}), ...); 
        return ret;
    }();
};

template<typename ... Devices>
constexpr const char * list_output = list<Devices...>::value.data();
}
// @/
```

The list command itself then simply serves up the precomputed value
when requested.

```c++
// @#'commands/list.hpp'
#pragma once

#include <array>
#include "utilities/metadata/names/names.hpp"

namespace bindings::cli::commands
{
@{generate output for list command}

template<typename ... Devices>
struct List
{
    static consteval auto name() { return "List"; }

    struct outputs_t
    {
        struct stdout_t
        {
            static consteval auto name() { return "standard text output"; }
            const char* value;
        } stdout;

        struct return_code_t
        {
            static consteval auto name() { return "return code"; }
            int value;
        } retcode;
    } outputs;

    template<typename... T>
    void main(int argc, char** argv, std::tuple<T...>&)
    {
        outputs.stdout.value = detail::list_output<Devices...>;
        outputs.retcode.value = 0;
    }

    void free() {}
};
}
// @/

Arguably it's a bit of a waste of program memory to compute this at
compile time, since it essentially duplicates the names of all the
devices in memory in a way that it's doubtful the compiler could
detect and optimize away.

// @+'commands headers'
#include "commands/list.hpp"
// @/
```

# Summary

```c++
// @#'cli.hpp'
#pragma once
@{commands headers}
// @/
```

# Building Tests

```c++
// @#'tests.cpp'
#include <catch2/catch_test_macros.hpp>
#include "cli.hpp"
#include <string>

using std::string;

using namespace bindings::cli::commands;

@{test devices}

@{tests}
// @/
```

```cmake
# @#'CMakeLists.txt'
add_executable(cli-tests tests.cpp)
target_link_libraries(cli-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(cli-tests)
# @/
```
