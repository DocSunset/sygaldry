# Name Dispatch

Many bindings, including initially the CLI, and eventually perhaps also Pd, OSC,
MIDI 2.0, and others, need to match a name provided at run-time to a list of
named entities such as components and endpoints.

# Tests

```c++
// @#'tests/name_dispatch/tests.cpp'
#include <string_view>
#include <tuple>
#include <catch2/catch_test_macros.hpp>
#include "utilities/consteval.hpp"
#include "components/testcomponent.hpp"
#include "components/endpoints/helpers.hpp"
#include "bindings/basic_logger/test_logger.hpp"
#include "bindings/name_dispatch.hpp"

using std::string_view;

using namespace sygaldry::bindings;
using namespace sygaldry::endpoints;

struct Config
{
    using basic_logger_type = basic_logger::TestLogger;
};

struct Named1 { static _consteval auto name() {return "name1";} int value = 0;};
struct Named2 { static _consteval auto name() {return "name2";} float value = 0;};
struct Named3 : named<"name3">, persistent<int> {};
struct Named4 : named<"name4">, persistent<float> {};

struct PseudoComponent1
{
    static _consteval auto name() {return "pseudo-component";}
    struct {
        Named1 in1;
        Named3 in2;
    } inputs;
    struct {
        Named2 out1;
        Named4 out2;
    } outputs;
};

TEST_CASE("Dispatch over tuple of named", "[bindings][dispatch]")
{
    std::tuple tup{Named1{}, Named2{}, Named3{}, Named4{}};
    auto ret = dispatch("name1", tup, "fail", [](auto& n) {return n.name();});
    REQUIRE(string_view(ret) == string_view("name1"));
}

TEST_CASE("Dispatch can mutate entities in tuple", "[bindings][dispatch]")
{
    std::tuple tup{Named1{}, Named2{}, Named3{}, Named4{}};
    REQUIRE(std::get<Named1>(tup).value == 0);
    auto ret = dispatch("name1", tup, 0, [](auto& n) {n.value = 42; return (int)n.value;});
    REQUIRE(ret == 42);
    REQUIRE(std::get<Named1>(tup).value == 42);
}

//TEST_CASE("Dispatch over struct of endpoints", "[bindings][dispatch]")
//{
//    PseudoComponent1 x{};
//    auto ret = dispatch("name1", x.inputs, "fail", [](auto& n) {return n.name();});
//    REQUIRE(string_view(ret) == string_view("name1"));
//}
//
//TEST_CASE("Dispatch can mutate entities in struct of endpoints", "[bindings][dispatch]")
//{
//    PseudoComponent1 x{};
//    REQUIRE(x.inputs.in1.value == 0);
//    auto ret = dispatch("name1", x.in1, 0, [](auto& n) {n.value = 42; return (int)n.value;});
//    REQUIRE(ret == 42);
//    REQUIRE(x.inputs.in1.value == 42);
//}

// @/
```

```cmake
# @#'tests/name_dispatch/CMakeLists.txt'
add_executable(dispatch-tests tests.cpp)
target_link_libraries(dispatch-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(dispatch-tests)
# @/
```

# Implementation

We assume that the entities are stored as a tuple. Because we may need to
short-circuit the iteration in case we find a matching entity, the only
adequate method for iterating over the commands is using a recursive variadic
function. This can't be a lambda, since it's obnoxious to try to `std::apply` a
tuple to a lambda that has to recursively call itself. Instead, we define a
template function for the purpose.

Many bindings will require names to be respelled according to a certain
transformation, e.g. defined as a functor in `utilities/spelling.hpp`.
We TODO will require such a transformation as a template parameter.

```c++
// @#'name_dispatch.hpp'
#pragma once
#include <tuple>
#include "utilities/spelling.hpp"

namespace sygaldry
{
namespace bindings
{

template<typename stringish, typename Default, typename Callback, typename NamedT, typename ... NamedTs>
auto _dispatch_impl(stringish name, Default&& d, Callback&& f, NamedT&& t, NamedTs&&... ts)
{
    if (std::string_view(name) == std::string_view(spelling::lower_kebab_case(t)))
        return f(t);
    else if constexpr (sizeof...(NamedTs) == 0)
        return d;
    else
        return _dispatch_impl(name, d, f, ts...);
}

template <typename stringish, typename TupleOfNamed, typename Default, typename Callback>
    requires requires { std::tuple_size_v<TupleOfNamed>; }
auto dispatch(stringish name, TupleOfNamed& tup, Default&& d, Callback&& f)
{
    if constexpr (std::tuple_size_v<TupleOfNamed> == 0) return d; // no impl if no t
    else return std::apply([&]<typename ... NamedTs>(NamedTs&& ... ts)
    {
        return _dispatch_impl(name, d, f, ts...);
    }, tup);
}

template <typename stringish, typename TupleOfNamed, typename Default, typename Callback>
auto wildcard_dispatch(stringish name, TupleOfNamed&& tup, Default&& d, Callback&& f)
{
    if constexpr (std::tuple_size_v<std::decay_t<TupleOfNamed>> == 0) return d;
    else if (std::string_view(name) == std::string_view("*")) return std::apply([&](auto& t)
    {
        return f(t);
    }, tup);
    else return dispatch(name, tup, d, f);
}

}
}
// @/
```


