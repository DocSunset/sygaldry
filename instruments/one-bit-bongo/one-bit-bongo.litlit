---
initial_lilit_escape: '@:$'
---

# The 1-Bit Bongo

A 1-Bit bongo is an infra-instrument [@bowers2005nime_infra-instruments]
conceived as a proof of concept and test platform for a modular digital
lutherie toolbox based on C++ reflection, inspired by Jean-Michael's
[Avendish](http://github.com/celerier/avendish) library
[@celerier2022icmc_rage-against-the-glue], and applied to both embedded
firmware and common creative coding environments used by digital luthiers, such
as Pure Data, that are usually run on a laptop computer.

The intended design of the instrument is a single button, e.g. the spacebar key
on a typical computer keyboard, mapped to a 1-bit synthesis algorithm
[@troise2020thesis; @troise2020_1-bit]. The design is sufficiently constrained
(or if you prefer, sufficiently simplistic) that its parts can be implemented
rapidly on a variety of platforms without much effort, but not so contrived
that those parts would be completely useless for other DMIs. As such, the 1-Bit
bongo is also intended as a first step towards implementing more featureful
digital musical instruments.

For this discussion, we will largely focus on realizing a 1-bit bongo using the
ESP32 platform. We will then generalize some of the signal models we develop to
run in Pure Data, which acts as a proxy for the rich ecosystem of sound and
music computing tools commonly employed. Finally, we will port the ESP32 bongo
to a different microcontroller platform. In the process, we will see how C++
reflection can help us to minimize repetition of effort and reduce how much
binding code it is necessary to write. Throughout the discussion that follows,
we will imagine that you are building the bongo for yourself and your artistic
collaborators. We will follow along the process of making the device, gradually
adding features, encountering problems, and hopefully resolving them.

# Bit Banger

Perhaps the simplest possible realization of a 1-bit bongo maps the button
directly to the output sound, typically producing electronic clicks when the
state of the button changes. In principle, if the player had superhuman
virtuosity, and the button had an idealistic analog response, then any sound
could be performed through a loudspeaker by performing a high frequency pulse
width modulation signal, such as would be produced from a class-D amplifier.
Although this could be easily realized as a purely analog system, with a
voltag connected through the button directly to the speaker, we will start
with a digital implementation on ESP32 so that we can reuse parts of it in
later steps.

First, we need to read the state of the button from a GPIO input pin. Then, we
will write that state to GPIO output pin. GPIO reference documentation for the
current version of the ESP integrated development framework (ESP-IDF) is found
[here](https://docs.espressif.com/projects/esp-idf/en/v5.0.1/esp32/api-reference/peripherals/gpio.html).
The relevant public domain example code is found 
[here](https://github.com/espressif/esp-idf/blob/v5.0.1/examples/peripherals/gpio/generic_gpio/main/gpio_example_main.c).

## Hardware Setup

Let's assume we have a normally open button connected to pulled-up-GPIO pin 4
on one side and electrical ground on the other, and a piezo buzzer or
loudspeaker connected to GPIO pin 18 on one side and ground on the other,
roughly following the pin assignments in the example code. We'll define compile
time constants near the beginning of the file to refer to the pin assignments.

```c++
// $:@
// @='define pin numbers'
constexpr gpio_num_t input_pin  = GPIO_NUM_4;
constexpr gpio_num_t output_pin = GPIO_NUM_18;
// @/
```

Before we can read or write the pins, we need to configure them. Again
following the example code, we can do this by passing a configuration structure
to the appropriate API function.

```c++
// @='configure pins'
// https://docs.espressif.com/projects/esp-idf/en/v5.0.1/esp32/api-reference/peripherals/gpio.html#_CPPv413gpio_config_t
gpio_config_t input_cfg =
{
    .pin_bit_mask = 1ULL<<input_pin,
    .mode = GPIO_MODE_INPUT,
    .pull_up_en = GPIO_PULLUP_ENABLE,
    .pull_down_en = GPIO_PULLDOWN_DISABLE,
    .intr_type = GPIO_INTR_DISABLE,
};

gpio_config_t output_cfg =
{
    .pin_bit_mask = 1ULL<<output_pin,
    .mode = GPIO_MODE_OUTPUT,
    .pull_up_en = GPIO_PULLUP_DISABLE,
    .pull_down_en = GPIO_PULLDOWN_DISABLE,
    .intr_type = GPIO_INTR_DISABLE,
};

gpio_config(&input_cfg);
gpio_config(&output_cfg);
// @/
```

## Mapping

Reading and writing GPIO pins are both accomplished with API calls, meaning the mapping
here is quite trivial. We want to avoid a click when we power up the device, so since
the button is pulled-up by default, we need to invert its reading, giving us a 0 when
the button is not pressed, and a 1 when the button is pressed.

```c++
// @='read button write speaker'
auto button_state = 1^gpio_get_level(input_pin);
gpio_set_level(output_pin, button_state);
// @/
```

## Build Automation

The ESP-IDF uses a modular component library built using CMake for its builds. To
compile our code, we need a few boilerplate CMake files and a particular directory
structure. These can be generated with the `idf.py` tool included with the framework:

```sh
# generate boilerplate project files
mkdir -p narrative
cd narrative
idf.py bit-banger
```

This gives us a handful of CMakeLists.txt files, and an empty main. We leave the
top level CMakeLists.txt unchanged:

```cmake
# @#'narrative/bit-banger/CMakeLists.txt'
cmake_minimum_required(VERSION 3.16)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(bit-banger)
# @/
```

But we will modify the CMakeLists.txt in the main directory to use our C++ main file:

```cmake
# @#'narrative/bit-banger/main/CMakeLists.txt'
idf_component_register(SRCS "bit-banger.cpp"
                    INCLUDE_DIRS ".")
# @/
```

## Summary

The final implementation is very simple.

```c++
// @#'narrative/bit-banger/main/bit-banger.cpp'
#include "driver/gpio.h"

@{define pin numbers}

extern "C" void app_main(void)
{
    @{configure pins}
    for(;;)
    {
        @{read button write speaker}
    }
}
// @/
```

# One-Button Controller

For the sake of discussion, let's say that we are satisfied with the hardware
functionality of our device, and wish to explore other mappings to sound. We
might want to make use of a more convient and familiar tool on our laptop,
specifically Pure Data for the sake of our discussion, to facilitate rapid
prototyping and exploration. It would also be convient to allow our
collaborators to use the device as a controller in their own custom
applications. A single button can be unexpectedly useful. It can be used to
step through a series of cues during a performance, or to trigger various
events. Live looping applications can also be realized with a single button.

The simplest approach to get the button's state into Pure Data might be to
print a 0 or 1 to the serial console, and parse that in the intended
prototyping environment. This is particularly simple on ESP32, since the
development framework provides a standard output that writes to the serial
UART, without requiring any setup or boilerplate. We only send the state out
when it changes so that we can easily detect state transitions downstream, and
to save bandwidth that we might need later.

```c++
// @='naively write button state'
if (button_state_changed) putc(button_state, stdio);
// @/
```

While many commonly used tools, including Pure Data, have no convenient built
in way of reading data from a serial device, let's suppose that we are willing
to use a third party external such as `[comport]`, and parse the serial output
as necessary. Now we can receive our button state in Pure Data with a simple
patch.

## Mapping

Over the course of our exploration, there are a number of mappings we might
converge on that commonly arise in the course of working with buttons.

It is useful in many circumstances to detect button state transitions, such as
the rising edge when the button state is changed to `1`, and the falling edge
when the button is released. Each transition may be used to trigger different
behaviors. This mapping is indeed so basic and essential that it is necessary
to implement many other typical button gesture models.

It may be useful in our mappings to differentiate when the button is pressed
down and held, compared to when it is pressed and then quickly released. This
could be used, for example, to momentarily enable a function while holding the
button, or to persistently toggle the function on or off. In a live looper this
could be used with recording or overdub functions.

It may be useful to differentiate between a single tap and two or more taps in
quick succession. One tap might trigger a certain event, while two taps trigger
a different event, and three another. One button is transformed into an arbitrary
number of discrete triggers, limited only by how quickly you can tap.

These kinds of mappings might initially be prototyped in Pure Data, but eventually
there are a variety of reasons why it might be advantageous to port them to the
firmware of the controller. For instance, it might be more convenient for your
collaborators to access the outputs of these mappings without having to run your
Pure Data patch.

For the sake of keeping the example simple at this point, let's suppose that we
only need to implement edge detection. Detecting state transitions is
straightforward, based on comparing the current state of the button with the
previous state.

```c++
// @='initial edge detector'
static auto previous = button_state;
bool rising_edge = false;
bool falling_edge = false;
if (previous != button_state)
{
    previous = button_state;
    rising_edge = button_state;
    falling_edge = not button_state;
}
bool any_edge = rising_edge || falling_edge;
// @/
```

## Problems in the Implementation of DMIs

Having now developed our one-button controller to a sufficiently featureful
state, we begin to encounter some of the issues facing the implementation of
DMIs. Our firmware now performs some gesture modelling and generates a few
useful signals from the button. The problems being to emerge as we expose these
outputs to the user or try to port our instrument to a different platform.

## The Problem of Protocols

Now that we have derived some more useful data from the button, we may wish to
communicate the button state and signals derived from it to a laptop for
further mapping and sound synthesis. As a first attempt, we might simply print
each signal to the serial console, prepended with a descriptive name:

```c++
// @='just print everything'
printf("rising_edge: %d\n", rising_edge);
printf("falling_edge: %d\n", falling_edge);
printf("any_edge: %d\n", any_edge);
// @/
```

While perhaps tenable for such a simple design, having to manually name each
parameter begins to become a large maintenance burden when dealing with
applications that have a larger number of inputs and outputs, especially when
more than one communication protocol is employed. For example, while this
approach only requires us to write three lines of code for now, if we later
want to add OSC output, libmapper, MIDI, or any other representations, the
amount of effort is multiplied by each wrapper around our endpoints. Adding
more signals increases the product. We have $N*M$ implementation effort, for
$N$ signals and $M$ bindings. Each binding may require repeating the name of
the signal, the place in memory where it is located, metadata about the signal
such as its range of values, etc. If any of these things need to change, or we
want to add new signals, updating all of the bindings becomes a significant
burden.

The T-Stick exemplifies this issue. At the time of writing. Approximately 340
out of 835 lines of code (40%) of the main implementation file are devoted to
repetitive marshalling of metadata and signal values through bindings to
libmapper and OSC protocols. Most signals are referred to at least 5 times,
spread out over the entire implementation of the firmware. Not only is it
difficult to reason about how to declare a new signal, even after figuring it
out and with an intimate understanding of all of the bindings, how the data
needs to be pushed around, etc., it is still an error prone, frustrating, and
unpleasant burden to extend the firmware with additional signals.

## The Problem of Portability

Another issue arises if we wish to port our gesture model to a different
platform. For example, we may wish to test if the mapping significantly
influences the action-sound latency of the device; perhaps by moving the
mapping back out of the firmware, we can increase the rate at which the
button's state is measured. Or we may wish to transfer the design to a
different computing platform; perhaps we want to port the code to Bela so that
we can run the new synthesis algorithms we've been developing in a fully
self-contained device, or perhaps we wish to switch to a different MCU that
provides USB connectivity for using MIDI or HID protocols.

In any case, we will unavoidably need to reimplement strongly hardware-dependent
parts of the code, such as reading the button from a GPIO pin. But other parts
of the design, such as the gesture model, should be reasonably portable.
However, some complexity arises particularly when porting the gesture model
to run in high level environments like Pure Data and Max/MSP. These environments
all have their own unique APIs for C/C++ extensions. In general, it is necessary
to declare each signal at runtime, with repetitive boilerplate that differs
depending on each API. Each additional API we wish to target multiplies
the amount of code we must write and maintain.

# Rage Against the Glue

Both of these issues are instances of the same problem, addressed by
Jean-Michael Celerier's [Avendish](http://github.com/celerier/avendish)
library, and more broadly, by an approach leveraging C++ reflection features
and compile-time code execution described in Celerier's 2022 paper "Rage
Against the Glue: Beyond Run-Time Media Frameworks with Modern C++"
[@celerier2022icmc_rage-against-the-glue].

Let's explore how this can be employed for the one-button controller.

## Reflect-able Button Mapping

First, it is necessary to refactor our button gesture model so that output
signals can be iterated over and inspected at compile time. In particular,
compile time iteration over the members of a C++ type requires, at the time of
writing, that the type be an aggregate, e.g. a `struct` without abstract bases
or virtual member functions.

Here is a possible realization. The outputs have been converted to
structures containing their value, with their metadata as compile-time
constants. The main processing method is identical to above, with variable
names appropriately changed to access the structure-endpoints.

```c++
// @='button-gestures first attempt'
struct ButtonEdgeDetector
{
    struct inputs_t {
        struct button_state_t {
            static consteval auto name() { return "Button State"; }
            bool value;
        } button_state;
    } inputs;

    struct outputs_t {
        struct rising_edge_t {
            static consteval auto name() { return "Rising Edge"; }
            bool value;
        } rising_edge;

        struct falling_edge_t {
            static consteval auto name() { return "Falling Edge"; }
            bool value;
        } falling_edge;

        struct any_edge_t {
            static consteval auto name() { return "Any Edge"; }
            bool value;
        } any_edge;
    } outputs;

    bool previous_button_state;

    void operator()
    {
        if (previous_button_state != inputs.button_state.value)
        {
            previous_button_state = inputs.button_state.value;
            outputs.rising_edge.value = inputs.button_state.value;
            outputs.falling_edge.value = not inputs.button_state.value;
        }
        outputs.any_edge.value = outputs.rising_edge.value || outputs.falling_edge.value;
    }
};
// @/
```

## Serial Output

While a bit verbose, by converting the endpoints of the model to compile-time
enumerable aggregates, we can now automatically generate bindings for our
simplistic serial protocol:

```c++
// @='automatically just print everything'
template<typename... Processors> void print_everything(Processors... ps);
template<> void print_everything() {};
template<typename Processor, typename... Processors>
void print_everything(Processor processor, Processors... ps)
{
    auto print_one_thing = [](auto endpoint) {
        printf("%s: %d", endpoint.name(), endpoint.value);
    };
    if constexpr (has_outputs<processor>)
        boost::pfr::for_each_field(processor.outputs, print_one_thing);
}
// @/
```

Conveniently, we no longer need to mention any of the output endpoints in order
to output them. As long as they conform to the expected port format (i.e. a
structure with a `name` method and a `value` member), the binding automatically
adapts. If we want to add new ports, or modify existing ones, such as changing
their names, then we can do so without having to modify the protocol binding.
Although the implementation of this automatic binding requires more code than
trivially printing every signal when there are only three signals, the
automatic binding's code-size remains constant, whereas the trivial manual
binding will grow proportionate with the number of signals in the application.
If we continue to add new gesture models for the button, such as latching
software switches or a tap counter, or if we add intermediate mappings related
to sound synthesis, the manual binding will quickly outgrow the automatic one,
and start to become a burden on development and maintenance.

## Pure Data Port

As another illustration of the benefits of this approach, let's consider a port
of our simple gesture model to run as a Pure Data external. A trivial port of
the model directly might look something like the following:

```c++
// @#'narrative/pd-edge-detector-port/edge_detect.c'
#include "m_pd.h"

static t_class *edge_detect_class;

typedef struct _edge_detect {
    t_object x_obj;
    int previous_button_state;
    t_outlet *any_edge, *falling_edge, *rising_edge;
} t_edge_detect;

void edge_detect_float_method(t_edge_detect *ed, t_floatarg f)
{
    int rising_edge = 0;
    int falling_edge = 0;
    int any_edge;
    int button_state = f != 0;

    if (ed->previous_button_state != button_state)
    {
        ed->previous_button_state = button_state;
        rising_edge = button_state;
        falling_edge = button_state == 0;
    }
    any_edge = rising_edge || falling_edge;

    if (rising_edge) outlet_float(ed->rising_edge, 1);
    else outlet_float(ed->rising_edge, 0);

    if (falling_edge) outlet_float(ed->falling_edge, 1);
    else outlet_float(ed->falling_edge, 0);

    if (any_edge) outlet_float(ed->any_edge, 1);
    else outlet_float(ed->any_edge, 0);
}

void *edge_detect_new(t_symbol *s, int argc, t_atom *argv)
{
    t_edge_detect *ed = (t_edge_detect *)pd_new(edge_detect_class);

    ed->previous_button_state = atom_getfloatarg(0, argc, argv) != 0;

    ed->any_edge = outlet_new(&ed->x_obj, &s_float);
    ed->falling_edge = outlet_new(&ed->x_obj, &s_float);
    ed->rising_edge = outlet_new(&ed->x_obj, &s_float);

    return (void *)ed;
}

void edge_detect_setup(void)
{
    edge_detect_class = class_new(gensym("edge_detect"),
        (t_newmethod)edge_detect_new,
        0, sizeof(t_edge_detect),
        CLASS_DEFAULT,
        A_GIMME, 0);

    class_addfloat(edge_detect_class, (t_method)edge_detect_float_method);
}
// @/
```

This can be compiled, leveraging pd-lib-builder, using the following Makefile:

```sh
# @#'narrative/pd-edge-detector-port/Makefile'
lib.name = edge_detect
class.sources = edge_detect.c
include pd-lib-builder/Makefile.pdlibbuilder
# @/
```

Notice that only about seven lines of code are spent on the actual algorithm,
while the rest is essentially boilerplate that grows in size linearly in the
number of inputs and outputs of the algorithm. For each output, an outlet must
be allocated and later updated. For each input, a creation argument may specify
its initial state, an input method must be defined and added to the object.

## Pure Data Binding

Strictly speaking, all that is necessary to introduce a Pd external to the
runtime is for there to be a C function `void library_name_setup(void)` in the
dynamically linked library `library_name` that registers the external by
calling `class_new`. For the external to be useful, a constructor should be
registered during the call to `class_new`, and methods should be attached to
the inlets of the class using the `t_class` pointer returned by `class_new`.
The external's constructor should create a new object instance of the class by
calling `pd_new`, handle creation arguments, and create inlets and outlets.
Then all that's left is to process input data appropriately and send messages
and signals out.

Now here's a binding directly leveraging the reflect-able implementation above.

```c++
// @#'narrative/pd-edge-detector-port/automatic-binding.h
#include "m_pd.h"

template<typename MaybePort>
consteval bool is_a_port(MaybePort mp)
{
    if constexpr (requires mp.name())
    {
        if constexpr (requires mp.value)
    }
}

template<typename PortStruct>
consteval size_t number_of_ports(PortStruct port_struct)
{

}

template<typename Processor>
struct t_processor
{
    t_obj x_obj;
    Processor processor;
};

template<typename Processor>
struct PdBinding
{
    static t_class *processor_class;
    PdBinding()
    {
        using processor = t_processor<Processor>;

        constexpr auto processor_new = +[]() {};
        constexpr auto processor_free = +[]() {};
        constexpr auto processor_anything_method = +[]() {};

        processor_class = class_new(gensym(processor::c_name()),
            (t_newmethod)processor_new,
            (t_method)processor_free, sizeof(t_edge_detect),
            CLASS_DEFAULT,
            A_GIMME, 0);

        class_addanything(processor_class, (t_method)processor_anything_method);
    }
};

#define MAKE_PD_BINDING(LIBNAME, PROCESSOR) \
extern "C" void LIBNAME##_setup(void) \
{ \
    static const PureDataBinding<PROCESSOR> processor_class{}; \
    binding.class_new(); \
}
// @/
```
