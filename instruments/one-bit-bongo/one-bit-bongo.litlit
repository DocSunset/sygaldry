# The 1-Bit Bongo

A 1-Bit bongo is an infra-instrument [@bowers2005nime_infra-instruments]
conceived as a proof of concept and test platform for Sygaldry.

The intended design of the instrument is a single button, e.g. the spacebar key
on a typical computer keyboard, mapped to a 1-bit synthesis algorithm
[@troise2020thesis; @troise2020_1-bit]. The design is sufficiently constrained
(or if you prefer, sufficiently simplistic) that its parts can be implemented
rapidly on a variety of platforms without much effort, but not so contrived
that those parts would be completely useless for other DMIs. As such, the 1-Bit
bongo is also intended as a first step towards implementing more featureful
digital musical instruments.

For this discussion, we will largely focus on realizing a 1-bit bongo using the
ESP32 platform. We will then generalize some of the signal models we develop to
run in Pure Data, which acts as a proxy for the rich ecosystem of sound and
music computing tools commonly employed. Finally, we will port the ESP32 bongo
to a different microcontroller platform. In the process, we will see how C++
reflection can help us to minimize repetition of effort, improve software
modularity and testability, and reduce how much binding code it is necessary to
write. Throughout the discussion that follows, we will imagine that we are
building the bongo for ourselves and our artistic collaborators. We will follow
along the process of making the device, gradually adding features, encountering
problems, and hopefully resolving them.

# Bit Banger

Perhaps the simplest possible realization of a 1-bit bongo maps the button
directly to the output sound, typically producing electronic clicks when the
state of the button changes. In principle, if the player had superhuman
virtuosity, and the button had an idealistic analog response, then any sound
could be performed through a loudspeaker by performing a high frequency pulse
width modulation signal, such as would be produced from a class-D amplifier.
Although this could be easily realized as a purely analog system, with a
voltag connected through the button directly to the speaker, we will start
with a digital implementation on ESP32 so that we can reuse parts of it in
later steps.

First, we need to read the state of the button from a GPIO input pin. Then, we
will write that state to GPIO output pin. GPIO reference documentation for the
current version of the ESP integrated development framework (ESP-IDF) is found
[here](https://docs.espressif.com/projects/esp-idf/en/v5.0.1/esp32/api-reference/peripherals/gpio.html).
The relevant public domain example code is found 
[here](https://github.com/espressif/esp-idf/blob/v5.0.1/examples/peripherals/gpio/generic_gpio/main/gpio_example_main.c).

## Hardware Setup

Let's assume we have a normally open button connected to pulled-up-GPIO pin 4
on one side and electrical ground on the other, and a piezo buzzer or
loudspeaker connected to GPIO pin 18 on one side and ground on the other,
roughly following the pin assignments in the example code. We'll define compile
time constants near the beginning of the file to refer to the pin assignments.

```c++
// @='define pin numbers'
constexpr gpio_num_t input_pin  = GPIO_NUM_4;
constexpr gpio_num_t output_pin = GPIO_NUM_18;
// @/
```

Before we can read or write the pins, we need to configure them. Again
following the example code, we can do this by passing a configuration structure
to the appropriate API function.

```c++
// @='configure pins'
// https://docs.espressif.com/projects/esp-idf/en/v5.0.1/esp32/api-reference/peripherals/gpio.html#_CPPv413gpio_config_t
gpio_config_t input_cfg =
{
    .pin_bit_mask = 1ULL<<input_pin,
    .mode = GPIO_MODE_INPUT,
    .pull_up_en = GPIO_PULLUP_ENABLE,
    .pull_down_en = GPIO_PULLDOWN_DISABLE,
    .intr_type = GPIO_INTR_DISABLE,
};

gpio_config_t output_cfg =
{
    .pin_bit_mask = 1ULL<<output_pin,
    .mode = GPIO_MODE_OUTPUT,
    .pull_up_en = GPIO_PULLUP_DISABLE,
    .pull_down_en = GPIO_PULLDOWN_DISABLE,
    .intr_type = GPIO_INTR_DISABLE,
};

gpio_config(&input_cfg);
gpio_config(&output_cfg);
// @/
```

## Mapping

Reading and writing GPIO pins are both accomplished with API calls, meaning the mapping
here is quite trivial. We want to avoid a click when we power up the device, so since
the button is pulled-up by default, we need to invert its reading, giving us a 0 when
the button is not pressed, and a 1 when the button is pressed.

```c++
// @='read button write speaker'
auto button_state = 1^gpio_get_level(input_pin);
gpio_set_level(output_pin, button_state);
// @/
```

## Build System

The ESP-IDF uses a modular component library built using CMake for its builds.
To compile our code, we need a few boilerplate CMake files and a particular
directory structure. These can be generated with the `idf.py` tool included
with the ESP-IDF:

```sh
# generate boilerplate project files
mkdir -p narrative
cd narrative
idf.py bit-banger
```

This gives us a handful of CMakeLists.txt files, and an empty main. We leave
the top level CMakeLists.txt unchanged:

```cmake
# @#'narrative/bit-banger/CMakeLists.txt'
cmake_minimum_required(VERSION 3.16)
include($ENV{IDF_PATH}/tools/cmake/project.cmake)
project(bit-banger)
# @/
```

But we will modify the CMakeLists.txt in the main directory to use our C++ main
file:

```cmake
# @#'narrative/bit-banger/main/CMakeLists.txt'
idf_component_register(SRCS "bit-banger.cpp"
                    INCLUDE_DIRS ".")
# @/
```

## Summary

The final implementation is very simple.

```c++
// @#'narrative/bit-banger/main/bit-banger.cpp'
#include "driver/gpio.h"

@{define pin numbers}

extern "C" void app_main(void)
{
    @{configure pins}
    for(;;)
    {
        @{read button write speaker}
    }
}
// @/
```

# One-Button Controller

For the sake of discussion, let's say that we are satisfied with the hardware
functionality of our device, and wish to explore other mappings to sound. We
might want to make use of a more convient and familiar tool on our laptop,
let's say Pure Data for the sake of our discussion, to facilitate rapid
prototyping and exploration. It would also be convient to allow our
collaborators to use the device as a controller in their own custom
applications. A single button can be unexpectedly useful. It can be used to
step through a series of cues during a performance, or to trigger various
events. Live looping applications can also be realized with a single button.

The simplest approach to get the button's state into Pure Data might be to
print a 0 or 1 to the serial console, and parse that in the intended
prototyping environment. This is particularly simple on ESP32, since the
development framework provides a standard output that writes to the serial
UART, without requiring any setup or boilerplate. We only send the state out
when it changes so that we can easily detect state transitions downstream, and
to save bandwidth that we might need later.

```c++
// @='naively write button state'
if (button_state_changed) putc(button_state, stdio);
// @/
```

While many commonly used tools, including Pure Data, have no convenient built
in way of reading data from a serial device, let's suppose that we are willing
to use a third party external such as `[comport]`, and parse the serial output
as necessary. Now we can receive our button state in Pure Data with a simple
patch.

## Mapping

Over the course of our exploration, there are a number of mappings we might
converge on that commonly arise in the course of working with buttons.

It is useful in many circumstances to detect button state transitions, such as
the rising edge when the button state is changed to `1`, and the falling edge
when the button is released. Each transition may be used to trigger different
behaviors. This mapping is indeed so basic and essential that it is necessary
to implement many other typical button gesture models.

It may be useful in our mappings to differentiate when the button is pressed
down and held, compared to when it is pressed and then quickly released. This
could be used, for example, to momentarily enable a function while holding the
button, or to persistently toggle the function on or off. In a live looper this
could be used with recording or overdub functions.

It may be useful to differentiate between a single tap and two or more taps in
quick succession. One tap might trigger a certain event, while two taps trigger
a different event, and three another. One button is transformed into an arbitrary
number of discrete triggers, limited only by how quickly you can tap.

These kinds of mappings might initially be prototyped in Pure Data, but eventually
there are a variety of reasons why it might be advantageous to port them to the
firmware of the controller. For instance, it might be more convenient for your
collaborators to access the outputs of these mappings without having to run your
Pure Data patch.

For the sake of keeping the example simple at this point, let's suppose that we
find edge detection especially useful, and wish to move this part of the
mapping into the firmware so that our collaborators can use it without having
to run our Pure Data patch. Detecting state transitions is straightforward,
based on comparing the current state of the button with the previous state.

```c++
// @='initial edge detector'
static auto previous = button_state;
bool rising_edge = false;
bool falling_edge = false;
if (previous != button_state)
{
    previous = button_state;
    rising_edge = button_state;
    falling_edge = not button_state;
}
bool any_edge = rising_edge || falling_edge;
// @/
```

## Problems in the Implementation of DMIs

Having now developed our one-button controller to a sufficiently featureful
state, we begin to encounter some of the issues facing the implementation of
DMIs. Our firmware now performs some gesture modelling and generates a few
useful signals from the button. The problems being to emerge as we expose these
outputs to the user or try to port our instrument to a different platform.

## The Problem of Protocols

Now that we have derived some more useful data from the button, we may wish to
communicate the button state and signals derived from it to a laptop for
further mapping and sound synthesis. As a first attempt, we might simply print
each signal to the serial console, prepended with a descriptive name:

```c++
// @='just print everything'
printf("rising_edge: %d\n", rising_edge);
printf("falling_edge: %d\n", falling_edge);
printf("any_edge: %d\n", any_edge);
// @/
```

While perhaps tenable for such a simple design, having to manually name each
parameter begins to become a large maintenance burden when dealing with
applications that have a larger number of inputs and outputs, especially when
more than one communication protocol is employed. For example, while this
approach only requires us to write three lines of code for now, if we later
want to add OSC output, libmapper, MIDI, or any other representations, the
amount of effort is multiplied by each wrapper around our endpoints. Adding
more signals increases the product. We have $N*M$ implementation effort, for
$N$ signals and $M$ bindings. Each binding may require repeating the name of
the signal, the place in memory where it is located, metadata about the signal
such as its range of values, etc. If any of these things need to change, or we
want to add new signals, updating all of the bindings becomes a significant
burden.

The T-Stick exemplifies this issue. At the time of writing. Approximately 340
out of 835 lines of code (40%) of the main implementation file are devoted to
repetitive marshalling of metadata and signal values through bindings to
libmapper and OSC protocols. Most signals are referred to at least 5 times,
spread out over the entire implementation of the firmware. Not only is it
difficult to reason about how to declare a new signal, even with an intimate
understanding of all of the bindings, how the data needs to be pushed around,
etc., it is still an error prone, frustrating, and unpleasant burden to extend
the firmware with additional signals.

## The Problem of Portability

Another issue arises if we wish to port our gesture model to a different
platform. For example, we may wish to test if the mapping significantly
influences the action-sound latency of the device; perhaps by moving the
mapping back out of the firmware e.g. into Pure Data, we can increase the rate
at which the button's state is measured. Or we may wish to transfer the design
to a different computing platform; perhaps we want to port the code to Bela so
that we can run the new synthesis algorithms we've been developing in a fully
self-contained device, or perhaps we wish to switch to a different MCU that
provides USB connectivity for using MIDI or HID protocols.

In any case, we will unavoidably need to reimplement strongly hardware-dependent
parts of the code, such as reading the button from a GPIO pin. But other parts
of the design, such as the gesture model, should be reasonably portable.
However, some complexity arises particularly when porting the gesture model
to run in high level environments like Pure Data and Max/MSP. These environments
all have their own unique APIs for C/C++ extensions. In general, it is necessary
to declare each signal at runtime, with repetitive boilerplate that differs
depending on each API. Each additional API we wish to target multiplies
the amount of code we must write and maintain.

# Rage Against the Glue

Both of these issues are instances of the same problem, addressed by
Jean-Michael Celerier's [Avendish](http://github.com/celerier/avendish)
library, and more broadly, by an approach leveraging C++ reflection features
and compile-time code execution described in Celerier's 2022 paper "Rage
Against the Glue: Beyond Run-Time Media Frameworks with Modern C++"
[@celerier2022icmc_rage-against-the-glue].

Let's explore how this can be employed for the one-button controller.

## Reflect-able Button Mapping

First, it is necessary to refactor our button gesture model so that output
signals can be iterated over and inspected at compile time. In particular,
compile time iteration over the members of a C++ type requires, at the time of
writing, that the type be an aggregate, e.g. a `struct` without abstract bases
or virtual member functions.

Here is a possible realization. The outputs have been converted to
structures containing their value, with their metadata as compile-time
constants. The main processing method is identical to above, with variable
names appropriately changed to access the structure-endpoints.

```c++
// @#'narrative/first_button_gesture_model/button_gesture_model.hpp'
#pragma once

struct ButtonGestureModel
{
    static consteval auto name() { return "Button Gesture Model"; }

    struct inputs_t {
        struct button_state_t {
            static consteval auto name() { return "button state"; }
            bool value;
        } button_state;
    } inputs;

    struct outputs_t {
        struct rising_edge_t {
            static consteval auto name() { return "rising edge"; }
            bool value;
        } rising_edge;

        struct falling_edge_t {
            static consteval auto name() { return "falling edge"; }
            bool value;
        } falling_edge;

        struct any_edge_t {
            static consteval auto name() { return "any edge"; }
            bool value;
        } any_edge;

        struct debounced_state_t {
            static consteval auto name() { return "debounced state"; }
            bool value;
        } debounced_state;
    } outputs;

    void operator()()
    {
        if (outputs.debounced_state.value != inputs.button_state.value)
        {
            outputs.debounced_state.value = inputs.button_state.value;
            outputs.rising_edge.value = inputs.button_state.value;
            outputs.falling_edge.value = not inputs.button_state.value;
            outputs.any_edge.value = true;
        }
        else
        {
            outputs.rising_edge.value = outputs.falling_edge.value
                                      = outputs.any_edge.value = false;
        }
    }
};
// @/
```

## Serial Output

While a bit verbose, by converting the endpoints of the model to compile-time
enumerable aggregates, we can now automatically generate bindings for our
simplistic serial protocol:

```c++
// @='automatically just print everything'
template<typename... Processors> void print_everything(Processors... ps);
template<> void print_everything() {};
template<typename Processor, typename... Processors>
void print_everything(Processor processor, Processors... ps)
{
    auto print_one_thing = [](auto endpoint) {
        if constexpr (requires {endpoint.name();} )
        {
            if constexpr (requires {endpoint.value;})
                printf("    %s: %d\n", endpoint.name(), endpoint.value);
            else
            {
                printf("%s\n", endpoint.name());
            }

        }
    };
    boost::pfr::for_each_field(processor.inputs, print_one_thing);
    boost::pfr::for_each_field(processor.outputs, print_one_thing);
}
// @/
```

Which can be tentatively validated offline by this brief listing:

```c++
// @#'narrative/just_print/main.cpp'
#include <boost/pfr.hpp>
#include "../first_button_gesture_model/button_gesture_model.hpp"
@{automatically just print everything}

int main()
{
    ButtonGestureModel bgm{};
    print_everything(bgm);
    bgm.inputs.button_state.value = true;
    bgm();
    print_everything(bgm);
    bgm();
    print_everything(bgm);
    bgm.inputs.button_state.value = false;
    bgm();
    print_everything(bgm);
}
// @/
```

```cmake
# @#'narrative/just_print/CMakeLists.txt'
add_executable(one-bit-bongo-just-print main.cpp)
add_test(NAME one-bit-bongo-just-print COMMAND one-bit-bongo-just-print)
# @/

# @#'CMakeLists.txt'
add_subdirectory(narrative/just_print)
# @/
```

Conveniently, we no longer need to mention any of the output endpoints in order
to output them. As long as they conform to the expected port format (i.e. a
structure with a `name` method and a `value` member), the binding automatically
adapts. If we want to add new ports, or modify existing ones, such as changing
their names, then we can do so without having to modify the protocol binding.
Although the implementation of this automatic binding requires more code than
trivially printing every signal when there are only three signals, the
automatic binding's code-size remains constant, whereas the trivial manual
binding will grow proportionate with the number of signals in the application.
If we continue to add new gesture models for the button, such as latching
software switches or a tap counter, or if we add intermediate mappings related
to sound synthesis, the manual binding will quickly outgrow the automatic one,
and start to become a burden on development and maintenance.

## Pure Data Port

As another illustration of the benefits of this approach, let's consider a port
of our simple gesture model to run as a Pure Data external. A trivial port of
the model directly might look something like the following:

```c++
// @#'narrative/trivial-pd-edge-detector-port/edge_detect.c'
#include "m_pd.h"

static t_class *edge_detect_class;

typedef struct _edge_detect {
    t_object x_obj;
    int previous_button_state;
    t_outlet *any_edge, *falling_edge, *rising_edge;
} t_edge_detect;

void edge_detect_float_method(t_edge_detect *ed, t_floatarg f)
{
    int rising_edge = 0;
    int falling_edge = 0;
    int any_edge;
    int button_state = f != 0;

    if (ed->previous_button_state != button_state)
    {
        ed->previous_button_state = button_state;
        rising_edge = button_state;
        falling_edge = button_state == 0;
    }
    any_edge = rising_edge || falling_edge;

    if (rising_edge) outlet_float(ed->rising_edge, 1);
    else outlet_float(ed->rising_edge, 0);

    if (falling_edge) outlet_float(ed->falling_edge, 1);
    else outlet_float(ed->falling_edge, 0);

    if (any_edge) outlet_float(ed->any_edge, 1);
    else outlet_float(ed->any_edge, 0);
}

void *edge_detect_new(t_symbol *s, int argc, t_atom *argv)
{
    t_edge_detect *ed = (t_edge_detect *)pd_new(edge_detect_class);

    ed->previous_button_state = atom_getfloatarg(0, argc, argv) != 0;

    ed->any_edge = outlet_new(&ed->x_obj, &s_float);
    ed->falling_edge = outlet_new(&ed->x_obj, &s_float);
    ed->rising_edge = outlet_new(&ed->x_obj, &s_float);

    return (void *)ed;
}

void edge_detect_setup(void)
{
    edge_detect_class = class_new(gensym("edge_detect"),
        (t_newmethod)edge_detect_new,
        0, sizeof(t_edge_detect),
        CLASS_DEFAULT,
        A_GIMME, 0);

    class_addfloat(edge_detect_class, (t_method)edge_detect_float_method);
}
// @/
```

This can be compiled, leveraging pd-lib-builder, using the following Makefile:

```sh
# @#'narrative/trivial-pd-edge-detector-port/Makefile'
lib.name = edge_detect
class.sources = edge_detect.c
include pd-lib-builder/Makefile.pdlibbuilder
# @/
```

Notice that only about seven lines of code are spent on the actual algorithm,
while the rest is essentially boilerplate that grows in size linearly in the
number of inputs and outputs of the algorithm. For each output, an outlet must
be allocated and later updated. For each input, a creation argument may specify
its initial state, an input method must be defined and added to the object.
For each new mapping algorithm, a similar amount of new boilerplate must be
written.

## Pure Data Binding

How does an automatic binding compare in terms of size and complexity? Strictly
speaking, all that is necessary to introduce a Pd external to the runtime is
for there to be a C function `void LIBNAME_setup(void)` in the dynamically
linked library `LIBNAME` that registers the external by calling `class_new`. We
have to use a macro to generate this C function because of the requirement for
the library name to be part of the function name:

```c++
// @='setup macro'
#define MAKE_PD_BINDING(LIBNAME, Processor) \
extern "C" void LIBNAME##_setup(void) \
{ \
    processor_setup_internal<Processor>(); \
}
// @/
```

Similar to the following line from our manual port--

```c++
static t_class *edge_detect_class;
```

--our automatic binding works with a template variable parameterized by the
processor class:

```c++
// @='static t_class pointer'
template<typename Processor>
static t_class *processor_class;
// @/
```

And whereas the manual port defines a struct `t_edge_detect` that carries
object state, for the automatic binding we make a template struct, once again
parameterized on the processor type:

```c++
// @='define t_processor template'
template<typename Processor>
struct t_processor
{
    t_object x_obj;
    t_atom output;
    Processor processor;
};
// @/
```

The processor's own state is assumed to be contained in its own struct, which
is instantiated as part of `t_processor`. The rest of the struct contains
state data specific to the Pd binding.

The internal setup function creates the class, assigning to the static class
pointer for the given processor, and registering the size, constructor, and
methods with the class:

```c++
// @='processor setup internal'
template<typename Processor>
void processor_setup_internal()
{
    processor_class<Processor> = class_new(gensym(sygaldry::spelling::lower_snake_case_v<Processor>),
        (t_newmethod)processor_new<Processor>,
        0, sizeof(t_processor<Processor>),
        CLASS_DEFAULT,
        A_GIMME, 0);

    @{add methods}
}
// @/
```

The constructor handles creation arguments and creates an outlet:

```c++
// @='processor new'
template<typename Processor>
void * processor_new(t_symbol, int argc, t_atom *argv)
{
    t_processor<Processor> *obj = (t_processor<Processor> *)pd_new(processor_class<Processor>);

    @{parse args}

    outlet_new(&obj->x_obj, 0);
    return (void *)obj;
}
// @/
```

For now, one inlet and one outlet are used for all input and output ports, respectively. This
simplifies the binding somewhat at the cost of possibly providing a less idiomatic Pd object

The methods associated with the inlet simply set the associated port value. A `bang` method
is added which triggers the execution of the processor's function call operator and causes
its outputs to be serialized as messages from the outlet.

```c++
// @='add methods'
boost::pfr::for_each_field(Processor{}.inputs, [](auto endpoint)
{
    class_addmethod(processor_class<Processor>,
                    (t_method)setter_method<Processor, decltype(endpoint)>,
                    gensym(sygaldry::spelling::lower_kebab_case(endpoint)),
                    A_FLOAT, 0);
});
class_addbang(processor_class<Processor>, bang_method<Processor>);
// @/

// @='setter method'
template<typename Endpoint>
void set_value_from_float(Endpoint& ep, t_float f)
{
    if constexpr (std::is_same_v<decltype(ep.value), bool>)
    {
        ep.value = f != 0.0f;
    }
    else if constexpr (std::is_floating_point_v<decltype(ep.value)> || std::is_integral_v<decltype(ep.value)>)
    {
        ep.value = f;
    }
}

template<typename Processor, typename Input>
void setter_method(t_processor<Processor> *obj, t_float f)
{
    boost::pfr::for_each_field(obj->processor.inputs, [&f](auto& ep)
    {
        if constexpr (std::is_same_v<Input, std::remove_cvref_t<decltype(ep)>>)
        {
            set_value_from_float(ep, f);
        }
    });
}
// @/

// @='bang method'
template<typename Processor>
void bang_method(t_processor<Processor> *obj)
{
    using sygaldry::spelling::lower_kebab_case;
    obj->processor();
    boost::pfr::for_each_field(obj->processor.outputs, [&](auto endpoint)
    {
        SETFLOAT(&obj->output, static_cast<t_float>(endpoint.value));
        outlet_anything(obj->x_obj.ob_outlet, gensym(lower_kebab_case(endpoint)), 1, &obj->output);
    });
};
// @/
```

Similar to the input methods, the creation arguments merely initialize the
input port's values:

```c++
// @='parse args'
int i = 0;
boost::pfr::for_each_field(obj->processor.inputs, [&](auto& ep)
{
    if (i >= argc) return;
    set_value_from_float(ep, atom_getfloatarg(i, argc, argv));
    ++i;
});
obj->processor();
// @/
```

In summary:

```c++
// @#'narrative/automatic-pd-edge-detector-port/pd_binding.hpp'
#include <type_traits>
#include "m_pd.h"
#include <boost/pfr.hpp>
#include "utilities/spelling.hpp"

@{number of outlets}

@{static t_class pointer}

@{define t_processor template}

@{setter method}

@{bang method}

@{processor new}

@{processor setup internal}

@{setup macro}
// @/

// @#'narrative/automatic-pd-edge-detector-port/button_gesture_model.cpp'
#include "pd_binding.hpp"
#include "../first_button_gesture_model/button_gesture_model.hpp"

MAKE_PD_BINDING(button_gesture_model, ButtonGestureModel);
// @/
```

```sh
# @#'narrative/automatic-pd-edge-detector-port/Makefile'
lib.name = button_gesture_model
class.sources = button_gesture_model.cpp
cflags = -std=c++20 -I'../first_button_gesture_model' -I'./pfr/include' -I '../../../../' -I'../../../../dependencies/pfr/include'
include pd-lib-builder/Makefile.pdlibbuilder
# @/

```

```c++
// @#'narrative/automatic-pd-edge-detector-port/tests.cpp'
#include <catch2/catch_test_macros.hpp>
#include "pd_binding.hpp"
#include "../first_button_gesture_model/button_gesture_model.hpp"

@{first pd binding tests}
// @/
```

```cmake
# @#'narrative/automatic-pd-edge-detector-port/CMakeLists.txt'
add_executable(one-bit-bongo-first-pd-port tests.cpp)
target_link_libraries(one-bit-bongo-first-pd-port PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(one-bit-bongo-first-pd-port)
# @/

# @+'CMakeLists.txt'
add_subdirectory(narrative/automatic-pd-edge-detector-port/)
# @/
```

The implementation of this automatic Pd binding is about twice as many lines of
code as the trivial port. Much of this can be attributed to the more verbose
coding style required, involving template metaprogramming, `constexpr`
branches, and generally more generic writing. But even at this trivial level,
the benefits of this generic approach are already apparent during development.
As well as being considerably more amenable to change, as described above with
respect to the trivial text output binding, it should be noted that this Pure
Data binding needn't grow in size as the processors it binds increase in
quantity and complexity. Although the binding could be improved to work with
different sorts of ports designed based on different assumptions or have
different value types (e.g. vectors, matrices, optional monads, callback
function, etc.), insofar as the currently supported port format is sufficient,
an arbitrarily complex processor with hundreds of inputs would not require a
single additional line of code to be written in the binding. This should make
it clear how much effort is potentially saved through this approach.
The size and complexity of the binding code depends only on the details of
the target environment and the scope of the data representations the binding
is meant to be compatible with.
