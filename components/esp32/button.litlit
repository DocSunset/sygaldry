# ESP32 Button

This component is essentially simple, and a nice demonstration of
how at some point components start to come together almost magically
to make very high level constructions. All of the functionality of
this component is basically implemented elsewhere. The `GPIO` component
handles interaction with the hardware, and the `ButtonGestureModel`
component applies the required interpretation to the information from
the hardware, returning a rich set of higher-level descriptors of the
button's state and its evolution over time. All this implementation has
left to do is set up the GPIO for the purpose, and forward its data to
the gesture model.

```c++
// @#'button.hpp'
#pragma once

#include <components/sensors/button.hpp>
#include <components/esp32/gpio.hpp>

namespace sygaldry { namespace components { namespace esp32 {

enum class ButtonActive {High, Low};

template<gpio_num_t pin_number, ButtonActive active_level = ButtonActive::Low>
struct Button
: name_<"Button">
, author_<"Travis J. West">
, copyright_<"Travis J. West (C) 2023">
, description_<"A single button attached to a GPIO">
{
    ButtonGestureModel::inputs_t inputs;
    ButtonGestureModel::outputs_t outputs;
    struct parts_t { GPIO<pin_number> gpio; } parts;

    void init()
    {
        parts.gpio.init();
        parts.gpio.inputs.input_mode(parts.gpio);
        if constexpr (active_level == ButtonActive::Low) parts.gpio.inputs.enable_pullup(parts.gpio);
        else parts.gpio.inputs.enable_pulldown(parts.gpio);
    }

    void operator()()
    {
        inputs.button_state = (char)parts.gpio.outputs.level();
        ButtonGestureModel::main(inputs, outputs);
    }
};
    
} } }
// @/
```

# Tests

For now we just check if it compiles. It's assumed that since most of the
button's functionality is implemented in other (presumably well tested)
components, that the trivial implementation above can be verified by
inspection. If the button implementation here ever grows more complex, e.g.
incorporating interrupts or what have you, then tests should be incorporated at
that time as well.

```c++
// @#'tests/button.hpp'
#include <components/esp32/button.hpp>

void button()
{
    sygaldry::components::esp32::Button<GPIO_NUM_23> button; 
    button.init();
    button();
}
// @/
```
