# ESP32 GPIO

GPIO reference documentation for the current version of the ESP integrated
development framework (ESP-IDF) is found
[here](https://docs.espressif.com/projects/esp-idf/en/v5.0.2/esp32/api-reference/peripherals/gpio.html).
The relevant public domain example code is found
[here](https://github.com/espressif/esp-idf/blob/v5.0.2/examples/peripherals/gpio/generic_gpio/main/gpio_example_main.c).

This document implements a `sygaldry` component that attempts to expose all
available behavior for a single GPIO pin through `sygaldry`-style input and
output ports. It is currently implemented via the ESP-IDF. Not all
functionality has been wrapped yet, and much of it remains un-tested.

The ESP-IDF provides a very uniform interface for interacting with GPIO.
All methods return an `esp_err_t` error code, and all arguments (with the
exception of an interrupt handler callback) are either pin numbers or
enumerations; it can reasonably be assumed that these values are known
at compile time in almost all cases.

Our strategy for wrapping this API is to declare input endpoints as functors
that accept the parent `GPIO` as their only argument, check the error code, and
bypass the GPIO in case of issue. Because all of these functor implementations
are identical except for the names of things, we use a macro to facilitate
implementation without repeating ourselves.

# Endpoints

```c++
// @='gpio_function macro'
#define gpio_funcion(c_name, str_name, description, esp_idf_func, ... )\
struct c_name##_t : name_<str_name> , description_{description} {\
    auto operator()(GPIO& gpio) const noexcept {\
        if (gpio.inputs.bypass != 0) return ESP_FAIL;\
        auto ret = esp_idf_func(__VA_ARGS__);\
        ESP_ERROR_CHECK_WITHOUT_ABORT(ret);\
        if (ret != ESP_OK) gpio.inputs.bypass = true;\
        return ret;\
    }\
} c_name /* remember the semicolon */
// @/
```

Most (TODO: all) of the subroutines in the ESP-IDF GPIO API are then wrapped
in this manner, providing a name and description for each, so that the GPIO
component also serves as an executable user manual for the API.

## Inputs

```c++
// @='input wrappers'
// when bypass is not zero, all other endpoints are disabled and return ESP_FAIL
toggle<"bypass"> bypass;

// all following input methods return esp_err_t, either ESP_OK or an error code
gpio_function(remove_interrupt_handler, "remove interrupt handler", "remove the interrupt handler callback for this pin", gpio_isr_handler_remove, pin_number);
@{interrupt handler port}

// The documentation warns "ESP32: Please do not use the interrupt of GPIO36 and GPIO39 when using ADC or Wi-Fi and Bluetooth with sleep mode enabled."
gpio_function(enable_interrupt,  "enable interrupt",  "enable interrupt",  gpio_intr_enable, pin_number);
gpio_function(disable_interrupt, "disable interrupt", "disable interrupt", gpio_intr_disable, pin_number);

// the installer must only be called once for all GPIO
gpio_function(install_isr_service,   "install ISR service",   "install ISR hander service and free its resources",   gpio_install_isr_service);
gpio_function(uninstall_isr_service, "uninstall ISR service", "uninstall ISR hander service and free its resources", gpio_uninstall_isr_service);

gpio_function(reset,        "reset",        "reset pin and disconnect peripheral outputs", gpio_reset_pin,     pin_number);
gpio_function(rising_edge,  "rising edge",  "interrupt on rising edge",                    gpio_set_intr_type, pin_number, GPIO_INTR_POSEDGE);
gpio_function(falling_edge, "falling edge", "interrupt on falling edge",                   gpio_set_intr_type, pin_number, GPIO_INTR_NEGEDGE);
gpio_function(any_edge,     "any edge",     "interrupt on any edge",                       gpio_set_intr_type, pin_number, GPIO_INTR_ANYEDGE);
gpio_function(low_level,    "low level",    "interrupt on low level trigger",              gpio_set_intr_type, pin_number, GPIO_INTR_LOW_LEVEL);
gpio_function(high_level,   "high level",   "interrupt on high level trigger",             gpio_set_intr_type, pin_number, GPIO_INTR_HIGH_LEVEL);
gpio_function(high,         "high",         "set output level high",                       gpio_set_level,     pin_number, 1);
gpio_function(low,          "low",          "set output level low",                        gpio_set_level,     pin_number, 0);

// note: pins 34-39 have no pull resistors
gpio_function(enable_pullup,               "enable pull-up",                 "enable internal pull-up resistor",                      gpio_set_pull_mode,        pin_number, GPIO_PULLUP_ONLY);
gpio_function(enable_pulldown,             "enable pull-down",               "enable internal pull-down resistor",                    gpio_set_pull_mode,        pin_number, GPIO_PULLDOWN_ONLY);
gpio_function(enable_pullup_and_pulldown,  "enable pull-up and pull-down",   "enable both internal pull-up and pull-down resistors",  gpio_set_pull_mode,        pin_number, GPIO_PULLUP_PULLDOWN);
gpio_function(disable_pullup_and_pulldown, "disable pull-up and pull-down",  "disable both internal pull-up and pull-down resistors", gpio_set_pull_mode,        pin_number, GPIO_FLOATING);
gpio_function(disable_pullup,              "disable pull-up",                "disable internal pull-up resistor",                     gpio_pullup_dis,           pin_number);
gpio_function(disable_pulldown,            "disable pull-down",              "disable internal pull-down resistor",                   gpio_pulldown_dis,         pin_number);

gpio_function(rising_edge_wakeup,  "rising edge wake-up",  "enable wake-up on rising edge",        gpio_wakeup_enable,  pin_number, GPIO_INTR_POSEDGE);
gpio_function(falling_edge_wakeup, "falling edge wake-up", "enable wake-up on falling edge",       gpio_wakeup_enable,  pin_number, GPIO_INTR_NEGEDGE);
gpio_function(any_edge_wakeup,     "any edge wake-up",     "enable wake-up on any edge",           gpio_wakeup_enable,  pin_number, GPIO_INTR_ANYEDGE);
gpio_function(low_level_wakeup,    "low level wake-up",    "enable wake-up on low level trigger",  gpio_wakeup_enable,  pin_number, GPIO_INTR_LOW_LEVEL);
gpio_function(high_level_wakeup,   "high level wake-up",   "enable wake-up on high level trigger", gpio_wakeup_enable,  pin_number, GPIO_INTR_HIGH_LEVEL);
gpio_function(disable_wakeup,      "disable wake-up",      "disable wake-up functionality",        gpio_wakeup_disable, pin_number);
gpio_function(disable_wakeup,      "disable wake-up",      "disable wake-up functionality",        gpio_wakeup_disable, pin_number);

gpio_function(set_drive_weakest,   "set drive weakest",   "set drive capability", gpio_set_drive_capability, pin_number, GPIO_DRIVE_CAP_0);
gpio_function(set_drive_weak,      "set drive weak",      "set drive capability", gpio_set_drive_capability, pin_number, GPIO_DRIVE_CAP_1);
gpio_function(set_drive_medium,    "set drive medium",    "set drive capability", gpio_set_drive_capability, pin_number, GPIO_DRIVE_CAP_2);
gpio_function(set_drive_strong,    "set drive strong",    "set drive capability", gpio_set_drive_capability, pin_number, GPIO_DRIVE_CAP_DEFAULT);
gpio_function(set_drive_strongest, "set drive strongest", "set drive capability", gpio_set_drive_capability, pin_number, GPIO_DRIVE_CAP_3);

// TODO: hold, sleep hold, deep sleep hold, iomux, sleep sel, sleep dir, sleep pull, rtc pins, ...
// @/
```

### Interrupt Handler

As previously mentioned, the input port to install an interrupt handler is
an exception to the general pattern. The component defers design of an ISR
to the user, so this port accept a pointer to the ISR function and its
context as arguments and passes them to the ESP-IDF method.

```c++
// @='interrupt handler port'
struct interrupt_handler_t : name_<"interrupt handler">
        , description_<"set the interrupt handler callback for this pin"> {
    auto operator()(void (*handler)(void*), void* args) const noexcept {
        if (gpio.inputs.bypass != 0) return ESP_FAIL;
        auto ret = gpio_isr_handler_add(pin_number, handler, args);
        ESP_ERROR_CHECK_WITHOUT_ABORT(ret);
        if (ret != ESP_OK) gpio.inputs.bypass = 1;
        return ret;
    }
} interrupt_handler;
// @/
```

## Outputs

There are significantly fewer output endpoints, since reading data from the
GPIO is considerably less involved than configuring it just right.

One thing to note: since the only possible error for gpio_get_drive_capability
is ESP_ERR_INVALID_ARG and the only arg that could be invalid is the pin number
could be invalid, or the pointer could be null since we can statically
guarantee that neither of these is the case, we can ignore the error code from
this IDF function and avoid having to return the drive_capability by output
argument from out port.

```c++
// @='output wrappers'
gpio_function(level, "level", "GPIO input level (always zero for output pin)", gpio_get_level, pin_number);

struct drive_capability_t : name_<"drive capability">, description_<"drive strength capability"> {
    auto operator()(GPIO& gpio) const noexcept {
        auto ret = GPIO_DRIVE_CAP_DEFAULT;
        if (gpio.inputs.bypass != 0) return ret;
        gpio_get_drive_capability(pin_number, &ret);
        return ret;
    }
} drive_capability;
// @/
```

# Initialization and Pin Number Assertions

The GPIO doesn't actually require much initialization. A call to
`inputs.reset()` is more than adequate. We take the opportunity presented by
the method, however, to assert certain requirements on the pin number. Although
the ESP32 has up to 39 pins, many of these cannot conventionally be used for
one reason or another as GPIO. Pins 0 to 3 (pins 0 and 1 for strapping and pins
2 and 3 for UART) are used for programming and pins 6 to 11, 16, and 17 are
used for SPI flash memory--these pins cannot be used as GPIO in almost any
application. Furthermore: pins 12 to 15 are used for debugging with JTAG; pin
12 strapping additionally sets the LDO voltage regulator's output voltage at
boot; pins 5 and 15 strapping additionally set SDIO timing and debug logging
behaviors at boot; pins 20 and 28 to 31 are not mentioned in the documentation,
nor the datasheet, suggesting that these hypothetical GPIO do not exist; pins
18, 19, 21, 22, and 23 are also used for the `VSPI` serial peripheral
interface; pins 25 to 27 cannot be used at the same time as WiFi; and pins 32
to 39 are shared with one of the analog-to-digital converters. Indeed, there is
not a single pin on the ESP32 that is not multi-purpose. It is a GPIO starved
platform.

The most detailed documentation on pin functions can be found in the datasheet.
The documentation also provides additional guidance. The pinout diagram for
a given MCU board can offer further advice where available.

```c++
// @='init function with assertions'
void init()
{
    static_assert(GPIO_NUM_0 <= pin_number && pin_number <= GPIO_NUM_39,
        "pin number invalid");

    // comment these out if you really know what you're doing!
    static_assert(pin_number != GPIO_NUM_0, "GPIO0 is an important strapping pin"
            "used during boot to determine SPI boot (pulled up, default) or"
            "download boot (pulled down). It should not be used for GPIO")
    static_assert(pin_number != GPIO_NUM_1, "GPIO1 is UART TXD, used for"
            "programming, and should not be used for GPIO");
    static_assert(pin_number != GPIO_NUM_2, "GPIO2 is an important strapping pin"
            "that must be pulled down during boot to initiate firmware download."
            "It should not be used for GPIO");
    static_assert(pin_number != GPIO_NUM_3, "GPIO3 is UART_RXD, used for"
            "programming, and should not be used for GPIO");
    static_assert(!(GPIO_NUM_6 <= pin_number || pin_number <= GPIO_NUM_11
                || pin_number == GPIO_NUM_16 || pin_number == GPIO_NUM_17),
            "GPIO6-11, 16, and 17 are used by SPI flash memory and shoult not be"
            "used for GPIO");
    static_assert(pin_number != 20 && !(28 <= pin_number || pin_number <= 32),
            "GPIO20, and 28-32 likely don't exist, and can't be used for GPIO");

    inputs.reset();
}
// @/
```

# Summary

```c++
// @#'gpio.hpp'
#pragma once

#include <driver/gpio.h>
#include <hal/gpio_types.h>

namespace sygaldry { namespace components { namespace esp32 {

template<gpio_num_t pin_number>
struct GPIO
    : name_<"ESP32 GPIO Pin">
    , author_<"Travis J. West">
    , copyright_<"Travis J. West (C) 2023">
{
    @{gpio_function macro}
    struct inputs_t {
        @{input wrappers};
    } inputs;

    struct outputs_t {
        @{output wrappers};
    } outputs;

    #undef gpio_funcion

    @{init function with assertions}
};

} } }
// @/
```

# Tests

```c++
```

```cmake
```
