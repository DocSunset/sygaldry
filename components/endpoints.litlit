# Introduction

A digital musical instrument is an assemblage of components that generate,
process, and output various forms of information with numerous different
structures and temporal characteristics. We define a *port* as a point in the
flow of data that is associated with a certain component, and can be said to be
a source or destination of data flowing through the assemblage. We define an
*endpoint* as a port with which metadata is readily associated, such as a name
and range.

Imagine we have two components, `A` and `B`, where `A` is connected directly to
`B`. We call the endpoints of `A` from which data originate its *source
endpoints*. These endpoints can generally be given descriptive names related to
their interpretation with respect to `A`, e.g. "button state" if `A` is a
button, or "saw wave" if `A` is an oscillator. From `A`'s perspective, the data
coming from these endpoints are its *outputs*. Similarly, the endpoints of `B`
where data arrives are its *destination endpoints*, they can be described based
on their interpretation with respect to `B`, e.g. "bypass switch" or "cutoff
frequency", and from `B`'s perspective the data arriving at these endpoints are
its *inputs*. Notice that the data that `A` sees as outputs is the same data
that `B` sees as inputs. The interpretation of endpoints depends only on the
component with which they are associated.

This document is concerned with providing a convenient means for definine
endpoints that adhere to certain concepts. The concepts themselves, along with
generic functions for accessing the signals and metadata associated with
endpoints, are defined seperately in `endpoints/concepts.litlit`. It is advised
to read this document first.

# Endpoint Bases

There are many common kinds of endpoints in a digital musical instrument that
vary depending on the type of data sent or received from the endpoint and the
expected temporal semantics with which that data is sent or received. Some
kinds of endpoints are more common than others, so it's convenient to define
helper types to allow instances of these endpoints to be instantiated easily
and to ensure consistency between instances of similar endpoints.

Similarly, certain forms of metadata are shared across numerous different types
of endpoint. Metadata associated with endpoints can be used to guide binding
authors towards the intended interpretation of a component. Some metadata are
required, others are optional.

Considering Avendish as a point of reference, we can identify three different
physical (i.e. C++ source code-level) mechanisms for associating metadata with
a type. There are compile-time methods, such as a `static _consteval auto
name()` method that returns the epynomous label. There are sub-types with
standardized names and structures, such as a `struct range` with members `min`,
`max`, and `init`. And there are other names within the scope of the endpoint
(or component?) such as those introduced by a bare `enum` declaration, or a
`using` declared type alias.

Here we rely mainly on function calls, as this allows metadata and other common
features of endpoints to be composed through inheritance. This provides a
convenient declarative method for users to define their own endpoint types by
combining the basic building blocks themselves. In general, users are
anticipated to use the higher-level helpers and not the base classs, but the
latter remain available for users spinning up a custom type of endpoint.
In general, these helpers can also be used with components, e.g. `struct
mycomponent : name_<"Lowpass Filter">` or what have you.

Note that there is no problem with inheritance for endpoints or components, but
collections of endpoints such as the `inputs` and `outputs` structures of a
component are not allowed to have base classes. Such collections must be simple
aggregates in order to work with `boost::pfr`, which is our chosen reflection
method for the time being. The endpoints within these aggregates, however, have
no such restrictions, so component authors are, in principle, free to employ
whatever design methods they prefer for endpoints. Indeed, even a bare `float`
or similar is perfectly allowed, although it is challenging to associate
metadata with such an endpoint.

## Name and Other Text

All endpoints are required to have a name. To facilitate setting this
conveniently, one approach is to define a thin wrapper around a string literal
that allows us to pass string literals as template parameters. Then we define a
base class that takes a string template parameter and synthesizes a
compile-time evaluated name method.

```c++
// @+'endpoints includes'
#include <cstddef>
// @/

// @+'string literal'
template<std::size_t N>
struct string_literal
{
    char value[N];
    _consteval string_literal(const char (&str)[N]) noexcept
    {
        for (std::size_t i = 0; i < N; ++i) value[i] = str[i];
    }
};
// @/

template<string_literal str>
struct name_
{
    static _consteval auto name() {return str.value;}
};
```

The above `string_literal` combined with such a simple class may also be useful
for associating other kinds of textual metadata with an endpoint or component,
such as a unit, author, or description. We employ a macro to define
such classes, allowing us to easily add other textual metadata in this way.

```c++
// @+'endpoint bases'
#define text_struct(STRUCT_NAME, METHOD_NAME) template<string_literal str>\
struct STRUCT_NAME\
{\
    static _consteval auto METHOD_NAME() {return str.value;}\
}

text_struct(name_, name);
text_struct(author_, author);
text_struct(email_, email);
text_struct(license_, license);
text_struct(description_, description);
text_struct(uuid_, uuid);
text_struct(unit_, unit);
text_struct(version_, version);
text_struct(date_, date);

#undef text_struct
// @/
```

The main limitation with this approach is that the name of the base class
cannot be the same as the name of the method that it provides. It turns out
this limitation is not particularly more severe than those of any other
approach. For example, the strategy taken by Avendish is to provide a macro,
e.g. `halp_meta(author, "Jane Doe")` that expands to something like `static
_constexpr auto author() {return "Jane Doe";}`. In this case the user is
obliged to write out `halp_meta` for every point of metadata, which is no worse
than having to add an underscore after the the name of the metadata. The main
disadvantage of this approach is that it uses a macro, with the attendant
(though small) risks involved, whereas the approach shown above protects the
metadata within a namespace. Another possible disadvantage is that the name of
the metadata, e.g. "author" is not checked by the compiler, meaning one could
easily write "authr" by mistake and run into frustrating issues as a
consequence. This is also the macro method's main advantage: there's no need
for the helper library author to specify in advance all of the possible
metadata types. It seems likely both methods have similar if not identical
runtime performance. For now, we opt for the base-class approach in keeping
with our overall strategy.

```c++
// @+'tests'
template<string_literal str>
_consteval auto name() {return string_view{str.value};}

TEST_CASE("String literal", "[endpoints][string_literal]")
{
    REQUIRE(string_view(string_literal{"Hello world"}.value) == "Hello world");
    REQUIRE(name<"test">() == "test");
}

struct struct_with_name : name_<"foo"> {};
TEST_CASE("name_", "[endpoints][bases][name_]")
{
    REQUIRE(string_view(struct_with_name::name()) == string_view("foo"));
}
// @/
```

## Range and Initial Value

Many endpoints have a fixed range, such as the integral 0 to 127 of MIDI
control change messages. For compatibility with Avendish, we consider a default
initial value to be a part of the range of an endpoint, although arguably the
initial value should be seperate. Similar to the `name_` class, we define a
helper class that endpoints can inherit to specify their range.

Ideally, we would like to specify initial values and the minimum and maximum
boundaries of the range as non-type template parameters, e.g. `struct
myendpoint : range_<0.0f, 1.0f, 0.5f>`. Unfortunately, many compilers
such as `clang` still do not support floating point numbers as non-type
template parameters.

So it was that after going through several possible solutions--

```c++
struct myendpoint : range_<0.0f, 1.0f> {} // compiler error with clang
struct myendpoint : range_<{0.0f, 1.0f}> {} // init list is not an expression
struct myendpoint : range_<range{0.0f, 1.0f} {}; // redundant and ugly
struct myendpoint : with<range{0.0f, 1.0f} {}; // not bad, but we can do better
```

--it occurred to me while proofreading the previous section that the same
strategy could likely be employed with numbers as well as strings. Although
this is redundant for integral types, which are allowed in template parameters,
it's a minor tradeoff to accept both floats and integers in order to have a
single way of annotating a range. This gives us the ideal syntax in a way that
doesn't upset clang.

```c++
// @+'endpoint bases'
template<typename T>
concept arithmetic = std::integral<T> || std::floating_point<T>;
template<arithmetic T>
struct num_literal
{
    using type = T;
    T value;
    _consteval num_literal(T f) : value{f} {}
    operator T() {return value;}
};
// @/

// @+'endpoint bases'
template<num_literal _min, num_literal _max, num_literal _init = _min>
struct range_
{
    static _consteval auto range()
    {
        struct {
            decltype(_min.value) min = _min.value;
            decltype(_max.value) max = _max.value;
            decltype(_init.value) init = _init.value;
        } r;
        return r;
    }
};
// @/
```

// @+'tests'
struct struct_with_range : range_<0, 127> {};
struct struct_with_init : range_<0.0f, 100.0f, 42.0f> {};

TEST_CASE("Range", "[endpoints][bases][range]")
{
    SECTION("With range")
    {
        REQUIRE(struct_with_range::range().min == 0);
        REQUIRE(struct_with_range::range().max == 127);
        REQUIRE(struct_with_range::range().init == 0);
    }
    SECTION("With init")
    {
        REQUIRE(struct_with_init::range().init == 42.0f);
    }
}
// @/

## Persistent Values

An endpoint that has a persistent value across activations of a component is
well modelled by storing the value as a persistent member variable. It's
convenient to store this inside a struct to enable metadata to be associated
with the value in the form of compile-time evaluated methods, types, and
enumerators, but this makes accessing the value of the variable it cumbersome,
as in e.g. `outputs.parameter.value = inputs.parameter.value`. To ease this
discomfort, we with to provide conversion and assignment operators so that an
instance of a value class can be treated direclty as though it were the value
itself rather than a container for it, while also retaining the benefit of
providing a convenient containment point for metadata.

Unfortunately, assignment operators in particular are tricky to inherit due to
C++'s automatically generated default assignment operators, which shadow the
explicitly defined ones on our persistent value base class. We could explictly
drawn the base class's assignment into the derived class with a `using`
declaration in public scope, e.g. `using persistent<T>::operator=`, but then
assignment to the derived class would return a reference to the base class.

Another issue with conversion and assignment operators is that they should
ideally be defined differently depending on whether the value type is trivial
or not; in case of trivial value type, it's likely cheaper not to define move
semantics, and to assign by copy instead of reference, whereas more complex
containers may benefit from having these.

For now we accept the tradeoffs of inherited assignment operators and ignore
the performance optimizations associated with trivial types.

```c++
// @+'endpoint bases'
template <typename T>
struct persistent
{
    using type = T;
    T value;
    constexpr persistent() noexcept : value{} {}
    constexpr persistent(T&& t) noexcept {value = std::move(t);}
    constexpr persistent(const T& t) noexcept : value{t} {}
    constexpr operator T&() noexcept {return value;}
    constexpr operator const T&() const noexcept {return value;}
    constexpr auto& operator=(T&& t) noexcept {value = std::move(t); return *this;}
    constexpr auto& operator=(const T& t) noexcept {value = t; return *this;}
};
// @/

// @+'tests'
struct persistent_struct : persistent<int> {using persistent<int>::operator=;};
TEST_CASE("Persistent Value", "[endpoints][helpers][persistent]")
{
    auto s = persistent_struct{42};
    REQUIRE(s == 42);
    s = 88;
    REQUIRE(s == 88);
    static_assert(PersistentValue<persistent_struct>);
}
// @/
```


## Occasional Values

Sometimes updating a value should initiate activation of the processor, and
sometimes the processor outputs values that should be propagated immediately. A
convenient way to represent this, seen in Avendish, is using `std::optional` to
represent the temporal semantics of these updates. The platform is expected to
clear `std::optional` valued endpoints before activating a component so that it
can signal hot outputs and recognize hot inputs. Afterwards, the platform is
expected to inspect hot outputs and take appropriate action if any are present.
An important consequence of this semantics is that, unlike a persistent value
endpoint, the state of hot outputs is not expected to be the unaltered by the
platform across invocations of a component, and so cannot be used to carry
state across invocations as with a persistent value endpoint.

For now, we wholesale subsume `std::optional` by defining our occasional value
class as an alias for the former. There are probably good reasons not to do
this, not least of all that it gives us no control over the API for our
optional values, but it's a lowly hack that gets us moving on quickly, so we'll
take it for now.

```c++
// @+'endpoint bases'
template <typename T>
using occasional = std::optional<T>;
// @/

// @+'tests'
struct occasional_struct : occasional<int> { using occasional<int>::operator=; };
TEST_CASE("Occasional Value", "[endpoints][helpers][occasional]")
{
    auto s = occasional_struct{42};
    REQUIRE(bool(s) == true);
    REQUIRE(*s == 42);
    *s = 88;
    REQUIRE(*s == 88);
    s = decltype(s){};
    REQUIRE(bool(s) == false);
    static_assert(OccasionalValue<occasional_struct>);
}
// @/
```


## Tags

We can introduce arbitrary symbols into the scope of a class through a bare
`enum` declaration e.g. `enum { bang };`. Our bindings can then be designed to
look for such symbols, e.g. `if constexpr (requires {endpoint::bang;}) { ... }` and
behave depending on their presence or absence. There's no real need for a helper
class for this kind of metadata; trying to define a template class or a macro
gets cumbersome very quickly, and it's already pretty trivial to add an `enum`
to an endpoint.

# Basic Endpoints

Given the above ingredients, we now define some basic endpoints composed
from them.

```c++
// @+'helpers'
template<string_literal str, char init = 0>
struct button : occasional<char>, name_<str>, range_<0, 1, init>
{
    using occasional<char>::operator=;
};

template<string_literal str, char init = 0>
struct toggle : persistent<char>, name_<str>, range_<0, 1, init>
{
    using persistent<char>::operator=;
};

template<string_literal str
        , arithmetic T = float
        , num_literal<T> min = 0.0f
        , num_literal<T> max = 1.0f
        , num_literal<T> init = min
        >
struct slider : persistent<float>, name_<str>, range_<min, max, init>
{
    using persistent<float>::operator=;
};
// @/

As all of the functionality of these endpoints has been tested above where the
base classes were defined, we take the opportunity instead to make sure that
our helper endpoints adhere to the expected concepts defined elsewhere. We
also check that our helper endpoints have the expected sizes, equivalent to
their value types.

// @+'tests'
TEST_CASE("Basic Endpoints", "[endpoints][basic]")
{
    static_assert(OccasionalValue<button<"foo">>);
    static_assert(PersistentValue<toggle<"baz">>);
    static_assert(PersistentValue<slider<"baz">>);
    static_assert(has_range<button<"foo">>);
    static_assert(has_range<toggle<"bar">>);
    static_assert(has_range<slider<"baz">>);
    static_assert(has_name<button<"foo">>);
    static_assert(has_name<toggle<"bar">>);
    static_assert(has_name<slider<"baz">>);
    static_assert(OccasionalValue<button<"foo">&>);
    static_assert(PersistentValue<toggle<"bar">&>);
    static_assert(PersistentValue<slider<"baz">&>);
    static_assert(has_range<button<"foo">&>);
    static_assert(has_range<toggle<"bar">&>);
    static_assert(has_range<slider<"baz">&>);
    static_assert(has_name<button<"foo">&>);
    static_assert(has_name<toggle<"bar">&>);
    static_assert(has_name<slider<"baz">&>);
    static_assert(OccasionalValue<const button<"foo">&>);
    static_assert(PersistentValue<const toggle<"bar">&>);
    static_assert(PersistentValue<const slider<"baz">&>);
    static_assert(has_range<const button<"foo">&>);
    static_assert(has_range<const toggle<"bar">&>);
    static_assert(has_range<const slider<"baz">&>);
    static_assert(has_name<const button<"foo">&>);
    static_assert(has_name<const toggle<"bar">&>);
    static_assert(has_name<const slider<"baz">&>);
    static_assert(sizeof(button<"foo">) == sizeof(std::optional<bool>));
    static_assert(sizeof(toggle<"baz">) == sizeof(bool));
    static_assert(sizeof(slider<"baz">) == sizeof(float));

    auto s1 = slider<"baz">{};
    auto s2 = slider<"baz">{0.5f};
    s2 = 0.0f;
}
// @/
```

## Bang

Often an endpoint doesn't carry any value, but merely serves to convey that
an event has occurred. In Max/MSP and Pure Data, this kind of temporal
impulsive event without data is called a *bang*. We adopt the same naming
convention here.

A bang could be represented as `std::optional` of an empty type, but
measurements suggest that this actually takes more space than a `bool`, so we
instead opt to treat a persistent value endpoint tagged with the symbol `bang` as
our preferred bang representation; this requires us to give our bang class a
different name, but we consider this an acceptable tradeoff.

Another possible approach would be to employ a callback semantics, so that
triggering the bang would immediately pass execution to a function registered
by the platform. For now, we opt to retain value semantics, despite that callback
semantics might allow for a more space efficient implementation. Callback
semantics place a greater burden on the binding author that we would prefer to
avoid at this point.

```c++
// @+'helpers'
template<string_literal str>
struct bng : persistent<bool>, name_<str>
{
    using persistent<bool>::operator=;
    enum {bang, impulse};
    void operator()() {value = true;}
    void reset() {value = false;}
};
// @/
```

```c++
// @+'tests'
TEST_CASE("Bang", "[endpoints][bang]")
{
    auto b = bng<"foo">{};
    REQUIRE(bool(b) == false);
    b();
    REQUIRE(bool(b) == true);
    b.reset();
    REQUIRE(bool(b) == false);
    b = true;
    REQUIRE(bool(b) == true);
    b = {};
    REQUIRE(bool(b) == false);
    static_assert(Bang<decltype(b)>);
    static_assert(sizeof(decltype(b)) == sizeof(bool));
}
// @/
```

# Summary

```c++
// @#'endpoints.hpp'
#pragma once

#include <string_view>
#include <optional>
#include "utilities/consteval.hpp"

namespace sygaldry { namespace endpoints {

@{string literal}

@{endpoint bases}

@{helpers}

} } // namespaces
// @/

// @#'tests/endpoints/tests.cpp'

#include <catch2/catch_test_macros.hpp>
#include <string_view>
#include <type_traits>
#include <optional>
#include <boost/pfr.hpp>
#include "components/endpoints.hpp"
#include "components/concepts.hpp"

using namespace sygaldry::endpoints;
using namespace sygaldry::concepts;
using std::string_view;

@{tests}
// @/
```

```cmake
# @#'tests/endpoints/CMakeLists.txt'
add_executable(endpoints-tests tests.cpp)
target_link_libraries(endpoints-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(endpoints-tests)
# @/
```
