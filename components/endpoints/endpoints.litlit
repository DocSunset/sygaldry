# Introduction

A digital musical instrument is an assemblage of components that generate,
process, and output various forms of information with numerous different
structures and temporal characteristics. We define a *port* as a
point in the flow of data that is associated with a certain component,
and can be said to be a source or destination of data flowing through
the assemblage, and an *endpoint* as a port with which metadata is
readily associated.

Imagine we have two components, `A` and `B`, where `A` is connected directly to
`B`. We call the endpoints of `A` from which data originate its *source
endpoints*. These endpoints can generally be given descriptive names related to
their interpretation with respect to `A`, e.g. "button state" if `A` is a
button, or "saw wave" if `A` is an oscillator. From `A`'s perspective, the data
coming from these endpoints are its *outputs*. Similarly, the endpoints of `B`
where data arrives are its *destination endpoints*, they can be described based
on their interpretation with respect to `B`, e.g. "bypass switch" or "cutoff
frequency", and from `B`'s perspective the data arriving at these endpoints are
its *inputs*. Notice that the data that `A` sees as outputs is the same data
that `B` sees as inputs. The interpretation of endpoints depends only on the
component with which they are associated.

# Endpoint Bases

There are many common kinds of endpoints in a digital musical instrument that
vary depending on the type of data sent or received from the endpoint and the
expected temporal semantics with which that data is sent or received. Some
kinds of endpoints are more common than others, so it's convenient to define
helper types to allow instances of these endpoints to be instantiated easily
and to ensure consistency between instances of similar endpoints.

Similarly, certain forms of metadata are shared across numerous different types
of endpoint. Metadata associated with endpoints can be used to guide binding
authors towards the intended interpretation of a component. Some metadata are
required, others are optional. Considering Avendish as a point of reference, we
can identify three different kinds of metadata. There are compile-time
functions, such as the one used to get an endpoint's name. There are types with
standardized names and structures, such as a `struct range` with members `min`,
`max`, and `init`. And there are names within the scope of the endpoint (or
component?) such as those introduced by a bare `enum` declaration.

Here we rely mainly on function calls, as this allows metadata and other common
features of endpoints to be composed through inheritance. This provides a
convenient declarative method for users to define their own endpoint types by
combining the basic building blocks themselves. In general, users are
anticipated to use the higher-level helpers and not the base classs, but the
latter remain available for users spinning up a custom type of endpoint.

Note that there is no problem with inheritance for endpoints, but collections
of endpoints such as the `inputs` and `outputs` structures of a component are
not allowed to have base classes. Such collections must be simple aggregates in
order to work with `boost::pfr`. The endpoints within these aggregates,
however, have no such restrictions, so component authors are, in principle,
free to employ whatever design methods they prefer for endpoints. Indeed, even
a bare `float` or similar is perfectly allowed, although it is challenging to
associate metadata with such an endpoint.

## With

// @+'endpoint bases'
template<string_literal str>
struct named
{
    static _consteval auto name() {return str.value;}
};
// @/

// @+'tests'
struct struct_with_name : named<"foo"> {};
TEST_CASE("Named", "[endpoints][bases][named]")
{
    REQUIRE(string_view(struct_with_name::name()).size() == string_view("foo").size());
    REQUIRE(string_view(struct_with_name::name()) == string_view("foo"));
    constexpr auto n = struct_with_name::name();
    static_assert(is_aggregate_v<struct_with_name>);
}
// @/
```

We encourage bindings to access the name through an intermediate function
rather than directly through the endpoint's name method, so that we can eventually
easily support other conventions for storing and accessing the name besides
a method call.

```c++
// @+'inspectors'
template<typename T>
concept Named
    =  requires { {T::name()} -> std::convertible_to<std::string>; }
    || requires { {T::name()} -> std::convertible_to<std::string_view>; }
    || requires { {T::name()} -> std::convertible_to<const char *>; }
    ;

template<Named T>
_consteval auto get_name(const T&) { return T::name(); }

template<Named T>
_consteval auto get_name() { return T::name(); }
// @/

// @+'tests'
struct base_struct_with_name {static _consteval auto name() {return "yup";}};
TEST_CASE("get_name", "[components][endpoints][inspectors][get_name]")
{
    static_assert(Named<base_struct_with_name>);
    static_assert(Named<struct_with_name>);
    struct_with_name foo{};
    base_struct_with_name yup{};
    REQUIRE(get_name(foo) == string_view("foo"));
    REQUIRE(get_name<struct_with_name>() == string_view("foo"));
    REQUIRE(string_view(get_name(yup)) == string_view("yup"));
    REQUIRE(string_view(get_name<base_struct_with_name>()) == string_view("yup"));
}
// @/
```

## Range and Initial Value

Many endpoints have a fixed range, such as the integral 0 to 127 of MIDI
control change messages. For compatibility with Avendish, we consider a default
initial value to be a part of the range of an endpoint, although arguably the
initial value should be seperate. Similar to the `named` class, we define a
helper class that endpoints can inherit to specify their range.

Ideally, we would like to specify initial values and the minimum and maximum
boundaries of the range as non-type template parameters, e.g. `struct myendpoint :
ranged<0.0f, 1.0f>, inited<0.5f>`. Unfortunately, many compilers such as
`clang` still do not support floating point numbers as non-type template
parameters. 

I first considered to define helper structs to hold the min and max, so that I
would write `struct myendpoint : ranged<range{0.0f, 1.0f}>`, however the redundancy
of writing `ranged<range...>` is rather unpleasant. This lead me to the
following approach using template specialization, where we instead specialize a
template class depending on the type of its non-type template parameter. This
doesn't actually save any lines of code compared to defining a `ranged` class,
but it does lead to a more agreeable spelling when we declare the metadata. It
also leaves open the possibility that we may eventually incorporate other kinds
of numeric metadata by specializing `with` on a different parameter type.

```c++
// @+'endpoint bases'
template<typename T>
struct range
{
    const T min;
    const T max;
    const T init;

    _consteval range(const T _min, const T _max) noexcept
    : min{_min < _max ? _min : _max}
    , max{_min > _max ? _min : _max}
    , init{min}
    { }

    _consteval range(const T _min, const T _max, const T _init) noexcept
    : min{_min < _max ? _min : _max}
    , max{_min > _max ? _min : _max}
    , init{_init}
    { }
};

template<auto arg>
struct with {};

template<range r>
struct with<r>
{
    static _consteval auto range() {
        return r;
    }
};
// @/

// @+'tests'
struct struct_with_range : with<range{0, 127}> {};
struct struct_with_init : with<range{0.0f, 100.0f, 42.0f}> {};

TEST_CASE("Range", "[endpoints][bases][range]")
{
    SECTION("With range")
    {
        REQUIRE(struct_with_range::range().min == 0);
        REQUIRE(struct_with_range::range().max == 127);
        REQUIRE(struct_with_range::range().init == 0);
        static_assert(is_aggregate_v<struct_with_range>);
    }
    SECTION("With init")
    {
        REQUIRE(struct_with_init::range().init == 42.0f);
        static_assert(is_aggregate_v<struct_with_init>);
    }
}
// @/

// @+'inspectors'
template<typename T>
concept Ranged = requires
{
    T::range().min;
    T::range().max;
    T::range().init;
};

template<Ranged T>
_consteval auto get_range(const T&) { return T::range(); }

template<Ranged T>
_consteval auto get_range() { return T::range(); }
// @/

// @+'tests'
TEST_CASE("Ranged", "[components][endpoints][inspectors][ranged]")
{
    static_assert(Ranged<struct_with_range>);
    struct_with_range foo{};
    REQUIRE(get_range(foo).min == 0);
    REQUIRE(get_range(foo).max == 127);
    REQUIRE(get_range(foo).init == 0);
    REQUIRE(get_range<struct_with_range>().min == 0);
    REQUIRE(get_range<struct_with_range>().max == 127);
    REQUIRE(get_range<struct_with_range>().init == 0);
}
// @/
```

## Persistent Values

An endpoint that has a persistent value across activations of a component is well
modelled by storing the value as a persistent member variable. Unfortunately,
to maintain reflectability this value has to be stored inside a struct, which
makes accessing it cumbersome, as in e.g. `outputs.parameter.value =
inputs.parameter.value`. To ease this discomfort, we provide a class that
sweetens access to the value allowing the endpoint to be treated direclty
as though it were the value itself rather than a container for it. We call
these endpoint `persistent` in contrast with the next kind.

Unfortunately, assignment operators are tricky to inherit due to C++'s
automatically generated default assignment operators. For this reason, the
`persistent` type needs to be treated directly as an endpoint type (i.e. not
merely inherited), or the assignment operators need to be explictly drawn into
the derived class with a `using` declaration in public scope, e.g. `using
persistent::operator=`.

Note that we could define a specialization for the `persistent` class in case
`std::is_trivial_v<T>`; this allows us to avoid defining a move assignment
operator, and to use the slightly cheaper version of the copy assignment that
takes `T` instead of `const T&`. For now this is deemed premature optimization.

```c++
// @+'endpoint bases'
template <typename T>
struct persistent
{
    using type = T;
    T value;
    constexpr operator T&() noexcept {return value;}
    constexpr operator const T&() const noexcept {return value;}
    constexpr auto& operator=(T&& t) noexcept {value = std::move(t); return *this;}
    constexpr auto& operator=(const T& t) noexcept {value = t; return *this;}
};
// @/
```

We define a concept for detecting persistent value endpoints. We take
the opportunity to lay some ground work that will also be useful for our
occasional value endpoints in the next section.

```c++
// @+'inspectors'
template <typename T>
concept _value_like = requires (T t)
{
    t.value;
    T{t.value};
    t = t.value;
    t.value = t;
    t.value = t.value;
    t = t;
};

template <typename T>
concept PersistentValue
    =  _value_like<T>
    && std::default_initializable<T>;
// @/

// @+'tests'
struct persistent_struct : persistent<int> {using persistent<int>::operator=;};
TEST_CASE("Persistent Value", "[endpoints][helpers][persistent]")
{
    auto s = persistent_struct{42};
    REQUIRE(s == 42);
    s = 88;
    REQUIRE(s == 88);
    static_assert(is_aggregate_v<persistent_struct>);
    static_assert(PersistentValue<persistent_struct>);
}
// @/
```

## Occasional Values

Sometimes updating a value should initiate activation of the processor, and
sometimes the processor outputs values that should be propagated immediately. A
convenient way to represent this, borrowed from Avendish, is using
`std::optional` to represent the temporal semantics of these updates. The
platform is expected to clear `std::optional` valued endpoints before
activating a component so that it can signal hot outputs and recognize hot
inputs. Afterwards, the platform is expected to inspect hot outputs and take
appropriate action if any are present. An important consequence of this
semantics is that, unlike a regular value endpoint, the state of hot outputs is not
expected to be persistent across invocations of a component, and so cannot be
used to carry state across invocations as with a regular value endpoint.

For now, we wholesale subsume `std::optional` by defining our occasional value
class as an alias for the former.

```c++
// @+'endpoint bases'
template <typename T>
using occasional = std::optional<T>;
// @/
```

For the related concept, we take the minimum requirements that seem satisfying,
focusing on the pointer-style syntax enabled by std::optional and momentarily
ignoring the rest that it offers. We rely on a definition that we will examine
later when we define concepts for our `bang` type.

```c++
// @+'inspectors'
@{clearable flag}

template<typename T>
concept OccasionalValue = requires (T t)
{
    *t;
    T{*t};
    *t = *t;
} && ClearableFlag<T>;
// @/

// @+'tests'
struct occasional_struct : occasional<int> { using occasional<int>::operator=; };
TEST_CASE("Occasional Value", "[endpoints][helpers][occasional]")
{
    auto s = occasional_struct{42};
    REQUIRE(bool(s) == true);
    REQUIRE(*s == 42);
    *s = 88;
    REQUIRE(*s == 88);
    s = decltype(s){};
    REQUIRE(bool(s) == false);
    static_assert(is_aggregate_v<occasional_struct>);
    static_assert(OccasionalValue<occasional_struct>);
}
// @/
```

## Tags

We can introduce arbitrary symbols into the scope of a class through a bare
`enum` declaration e.g. `enum { bang };`. Our bindings can then be designed to
look for such symbols, e.g. `if constexpr (requires {endpoint::bang;}) { ... }` and
behave depending on their presence or absence. There's no real need for a helper
class for this kind of metadata; trying to define a template class or a macro
gets cumbersome very quickly, and it's already pretty trivial to add an `enum`
to an endpoint.

# Basic Endpoints

Given the above ingredients, we now define some basic endpoints composed
from them.

```c++
// @+'helpers'
template<string_literal str, bool init = false>
struct _btn : named<str>, with<range{false, true, init}> { };

template<string_literal str, bool init = false>
struct button : occasional<bool>, _btn<str, init>
{
    using occasional<bool>::operator=;
};

template<string_literal str, bool init = false>
struct toggle : persistent<bool>, _btn<str, init>
{
    using persistent<bool>::operator=;
};

template<string_literal str, range<float> range_arg = range<float>{0.0f, 1.0f, 0.0f}>
struct slider : persistent<float>, named<str>, with<range_arg>
{
    using persistent<float>::operator=;
};
// @/

// @+'tests'
TEST_CASE("Basic Endpoints", "[endpoints][basic]")
{
    static_assert(is_aggregate_v<button<"foo">>);
    static_assert(is_aggregate_v<toggle<"bar">>);
    static_assert(is_aggregate_v<slider<"baz">>);
}
// @/
```

## Bang

Often an endpoint doesn't carry any value, but merely serves to convey that
an event has occurred. In Max/MSP and Pure Data, this kind of temporal
impulsive event without data is called a *bang*. We adopt the same naming
convention here.

A bang could be represented as `std::optional` of an empty type, but
measurements suggest that this actually takes more space than a `bool`, so we
instead opt to treat a persistent value endpoint tagged with the symbol `bang` as
our preferred bang representation; this requires us to give our bang class a
different name, but we consider this an acceptable tradeoff.

Another possible approach would be to employ a callback semantics, so that
triggering the bang would immediately pass execution to a function registered
by the platform. For now, we opt to retain value semantics, despite that callback
semantics might allow for a more space efficient implementation. Callback
semantics place a greater burden on the binding author that we would prefer to
avoid at this point.

```c++
// @+'helpers'
template<string_literal str>
struct bng : persistent<bool>, named<str>
{
    using persistent<bool>::operator=;
    enum {bang, impulse};
    void operator()() {value = true;}
    void reset() {value = false;}
};
// @/
```

Our `bang` concept essentially just checks that the type has an enum value
called `bang` in its scope, and that it is a clearable flag, a concept we
also required for our `OccasionalValue` concept.

```c++
// @+'inspectors'
template<typename T>
concept Bang = requires (T t)
{
    requires std::is_enum_v<decltype(T::bang)>;
} && ClearableFlag<T>;
// @/
```

The `ClearableFlag` concept requires that we can convert a type to bool, and
that the boolean interpretation of a default constructed value of the type is
`false`. This is true of `std::optional`, `bool`, and also pointer types, if
I'm not mistaken. We assume that by assigning a value of this type to a
default-constructed value that we can set its boolean interpretation to
`false`, and check at least that constructing the type in this way has the
expected effect. This allows us to define a generic method for clearing values
that meet the requirements of `ClearableFlag`.

A client using the `bng` class defined above may prefer to use a different,
perhaps more expressive, method of clearing it. But for a binding author,
it's useful to have a way to clear a flag without having to know anything
about it other than that it is a valid flag; this is especially pertinent
given the assumption that occasional values and bangs should be cleared by
the environment between calls to a component's main subroutine.

```c++
// @+'clearable flag'
template<typename T>
concept ClearableFlag = requires (T t)
{
    bool(t);
    requires std::is_same_v<std::integral_constant<bool, bool(T{})>, std::false_type>;
    requires std::is_same_v<std::integral_constant<bool, bool(T{T{}})>, std::false_type>;
    t = T{};
};

template<ClearableFlag T>
constexpr void clear_flag(T& t)
{
    t = T{};
}
// @/

// @+'tests'
TEST_CASE("Bang", "[endpoints][bang]")
{
    auto b = bng<"foo">{};
    REQUIRE(bool(b) == false);
    b();
    REQUIRE(bool(b) == true);
    b.reset();
    REQUIRE(bool(b) == false);
    b = true;
    REQUIRE(bool(b) == true);
    b = {};
    REQUIRE(bool(b) == false);
    static_assert(is_aggregate_v<decltype(b)>);
    static_assert(Bang<decltype(b)>);
    static_assert(sizeof(decltype(b)) == 1);
}
// @/
```

# Inputs and Outputs

Endpoints are expected to be grouped by components as either inputs or outputs,
held in respective simple aggregate structures. Depending on the intent of the
component author, these may be instances of anonymous structs, named structs
without instances, or named structs with instances. Bindings should not assume
one or the other of these approaches to be prevalent, and so require a mechanism
to get the type or value of these groups of endpoints generically.

We make use of macros adapted from Avendish's public domain section
(`<avnd/concepts/common.hpp>`) to generate appropriate accessors in our
namespace. These give us `inputs_is_type<T>`, `inputs_is_value<T>`,
`inputs_type<T>`, `get_inputs(t)`, and the same four functions for outputs,
that will work whether there is a `struct inputs {};` or a `struct {} inputs;`.

```c++
// @+'inspectors'
#define type_or_value_qualification(Name)                                         \
  template <typename T>                                                           \
  concept Name##_is_value = requires(T t) { decltype(std::decay_t<T>::Name){}; }; \
                                                                                  \
  template <typename T>                                                           \
  concept Name##_is_type                                                          \
      = requires(T t) { !std::is_void_v<typename std::decay_t<T>::Name>; };       \
                                                                                  \
  template <typename T>                                                           \
  concept has_##Name = Name##_is_type<T> || Name##_is_value<T>;

#define type_or_value_reflection(Name)                                             \
  template <typename T>                                                            \
  struct Name##_type                                                               \
  {                                                                                \
    using type = void;                                                             \
  };                                                                               \
                                                                                   \
  template <Name##_is_type T>                                                      \
  struct Name##_type<T>                                                            \
  {                                                                                \
    using type = typename std::decay_t<T>::Name;                                   \
  };                                                                               \
                                                                                   \
  template <Name##_is_value T>                                                     \
  struct Name##_type<T>                                                            \
  {                                                                                \
    using type                                                                     \
        = std::remove_reference_t<decltype(std::declval<std::decay_t<T>>().Name)>; \
  };                                                                               \
  template <typename T>                                                            \
  using Name##_type_t = Name##_type<T>;                                            

#define type_or_value_accessors(Name)                 \
  template <typename T>                               \
    requires(Name##_is_type<T> || Name##_is_value<T>) \
  auto&& get_##Name(T&& t)                            \
  {                                                   \
    if constexpr(Name##_is_type<T>)                   \
      return typename std::decay_t<T>::Name{};        \
    else if constexpr(Name##_is_value<T>)             \
      return std::forward<T>(t).Name;                 \
  }

type_or_value_qualification(inputs)
type_or_value_reflection(inputs)
type_or_value_accessors(inputs)

type_or_value_qualification(outputs)
type_or_value_reflection(outputs)
type_or_value_accessors(outputs)

#undef type_or_value_qualification
#undef type_or_value_reflection
#undef type_or_value_accessors
// @/
```

# Summary

```c++
// @#'inspectors.hpp'
#pragma once

#include <concepts>
#include "utilities/consteval/consteval.hpp"

namespace sygaldry::endpoints
{
    @{inspectors}
}
// @/

// @#'helpers.hpp'
#pragma once

#include <string_view>
#include <optional>
#include "utilities/string_literal.hpp"
#include "utilities/consteval/consteval.hpp"

namespace sygaldry::endpoints
{
using sygaldry::utilities::string_literal;

@{endpoint bases}

@{helpers}

}
// @/

// @#'tests.cpp'

#include <catch2/catch_test_macros.hpp>
#include <string_view>
#include <type_traits>
#include <boost/pfr.hpp>
#include "helpers.hpp"
#include "inspectors.hpp"

using namespace sygaldry::endpoints;
using std::string_view;
using std::is_aggregate_v;

@{tests}
// @/
```

```cmake
# @#'CMakeLists.txt'
add_executable(endpoints-tests tests.cpp)
target_link_libraries(endpoints-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(endpoints-tests)
# @/
```
