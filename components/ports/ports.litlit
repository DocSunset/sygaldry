# Introduction

A digital musical instrument is an assemblage of components that generate,
process, and output various forms of information with numerous different
structures and temporal characteristics. We define a *port* as a
point in the flow of data that is associated with a certain component,
and can be said to be a source or destination of data flowing through
the assemblage.

## Endpoints

Imagine we have two components, `A` and `B`, where `A` is connected directly to
`B`. We call the ports of `A` from which data originate its *source endpoints*.
These ports can generally be given descriptive names related to their
interpretation with respect to `A`, e.g. "button state" if `A` is a button, or
"saw wave" if `A` is an oscillator. From `A`'s perspective, the data coming
from these endpoints are its *outputs*. Similarly, the ports of `B` where data
arrives are its *destination endpoints*, they can be described based on their
interpretation with respect to `B`, e.g. "bypass switch" or "cutoff frequency",
and from `B`'s perspective the data arriving at these endpoints are its
*inputs*. Notice that the data that `A` sees as outputs is the same data that
`B` sees as inputs. The interpretation of endpoints depends only on the
component with which they are associated.

## Throughpoints

Now suppose the `A` and `B` are connected by an intermediary mapping `M`, such
as a preset interpolator or neural network. `M` is trained on a dataset of
examples assocating values of `A`'s sources to intended values of `B`'s
destinations. `M` automatically generates a set of ports that exactly match
`A`'s source endpoints into which data from `A` will flow into `M`, as well as
a set of ports that exactly match `B`'s destination endpoints from which data
for `B` will flow out of `M`. `M`'s ports are thus mere reflections of those of
`A` and `B`, and do not carry their own semantic interpretation or meaningful
properties. We define such ports as *throughpoints*, in contrast with
endpoints. As another example of throughpoints, imagine that data flows out of
`B` from its own source endpoints and is connected to an automatic binding `P`
that forwards this data unchanged e.g. to a network control protocol or plugin
API. `P` may also be said to have destination throughpoints matched to `B`.
Whereas the endpoints of a component have a specific interpretation,
throughpoints adapt to match certain endpoints, often all of the endpoints of
another component, based on training data, or as a binding to a different
representation of the data. The interpretation of throughpoints depends on
information from the original source or final destination of the data flowing
through the port.

# Port Bases

There are many common kinds of endpoints in a digital musical instrument that
vary depending on the type of data sent or received from the endpoint and the
expected temporal semantics with which that data is sent or received. Some
kinds of endpoints are more common than others, so it's convenient to define
helper types to allow instances of these endpoints to be instantiated easily
and to ensure consistency between instances of similar endpoints.

Similarly, certain forms of metadata are shared across numerous different types
of endpoint. Metadata associated with endpoints can be used to guide binding
authors towards the intended interpretation of a component. Some metadata are
required, others are optional. Considering Avendish as a point of reference, we
can identify three different kinds of metadata. There are compile-time
functions, such as the one used to get an endpoint's name. There are types with
standardized names and structures, such as a `struct range` with members `min`,
`max`, and `init`. And there are names within the scope of the endpoint (or
component?) such as those introduced by a bare `enum` declaration.

Here we rely mainly on function calls, as this allows metadata and other common
features of ports to be composed through inheritance. This provides a
convenient declarative method for users to define their own port types by
combining the basic building blocks themselves.

## Names

All endpoints are required to have a name. To facilitate setting this conveniently,
we define a thin wrapper around a string literal that allows us to pass string
literals as template parameters to our helpers.

```c++
// @+'ports includes'
#include <cstddef>
// @/

// @+'port helpers'
template<std::size_t N>
struct string_literal
{
    char value[N];
    _consteval string_literal(const char (&str)[N]) noexcept
    {
        for (std::size_t i = 0; i < N; ++i) value[i] = str[i];
    }
};
// @/

// @+'tests'
template<string_literal str>
_consteval auto name() {return string_view{str.value};}

TEST_CASE("String literal", "[ports][string_literal]")
{
    REQUIRE(string_view(string_literal{"Hello world"}.value) == "Hello world");
    REQUIRE(name<"test">() == "test");
}
// @/
```

Then we can define a class template that endpoint helpers can inherit from to
gain a name method; in general, users are anticipated to use the helpers and
not the base class, but the latter remains available for users spinning up a
custom type of endpoint.

```c++
// @+'port bases'
template<string_literal str>
struct named
{
    static _consteval auto name() {return std::string_view{str.value};}
};
// @/

// @+'tests'
struct struct_with_name : named<"foo"> {};
TEST_CASE("Named", "[ports][bases][named]")
{
    REQUIRE(struct_with_name::name() == "foo");
    static_assert(is_aggregate_v<struct_with_name>);
}
// @/
```

## Range and Initial Value

Many endpoints have a fixed range, such as the integral 0 to 127 of MIDI
control change messages. In deviation from Avendish, we do not consider a
default initial value to be a part of the range of an endpoint, although we do
take the minimum value as the default if an explit initial value is not
specified. Similar to the `named` class, we define a helper class that
endpoints can inherit to specify their range, along with some type aliases
for the same.

Ideally, we would like to specify initial values and the minimum and maximum
boundaries of the range as non-type template parameters, e.g. `struct myport :
ranged<0.0f, 1.0f>, inited<0.5f>`. Unfortunately, many compilers such as
`clang` still do not support floating point numbers as non-type template
parameters. 

I first considered to define helper structs to hold the min and max, so that I
would write `struct myport : ranged<range{0.0f, 1.0f}>, inited<init{0.5f}>`. It
occurred to me that the resultant structure of `ranged` and `inited` would be
very similar, and that the repeating of `ranged<range...>` and
`inited<init...>` would be rather unpleasant. This lead me to the following
approach using template specialization:

```c++
// @+'port bases'
template<typename T>
struct range
{
    T min;
    T max;
    _consteval range(T _min, T _max) noexcept
    {
        min = _min < _max ? _min : _max;
        max = _min > _max ? _min : _max;
    }
};

template<typename T>
struct init
{
    T value;
    _consteval init(T x) noexcept : value{x} { }
};

template<auto arg>
struct with {};

template<range r>
struct with<r>
{
    static _consteval auto range() {
        return r;
    }
};

template<init i>
struct with<i>
{
    static _consteval auto init() {
        return i.value;
    }
};
// @/

// @+'port includes'
#include <type_traits>
// @/

// @+'tests'
struct struct_with_range : with<range{0, 127}> {};

TEST_CASE("Ranged", "[port][bases][ranged]")
{
    REQUIRE(struct_with_range::range().min == 0);
    REQUIRE(struct_with_range::range().max == 127);
    static_assert(is_aggregate_v<struct_with_range>);
}

struct struct_with_init : with<init{42.0f}> {};

TEST_CASE("Initialized", "[port][bases][initialized]")
{
    REQUIRE(struct_with_init::init() == 42.0f);
    static_assert(is_aggregate_v<struct_with_init>);
}
// @/
```

## Initial Value

As above.

```c++
// @+'tests'
// @/
```

## Persistent Values

An endpoint that has a persistent value across activations of a component is well
modelled by storing the value as a persistent member variable. Unfortunately,
to maintain reflectability this value has to be stored inside a struct, which
makes accessing it cumbersome, as in e.g. `outputs.parameter.value =
inputs.parameter.value`. To ease this discomfort, we provide a class that
sweetens access to the value allowing the endpoint to be treated direclty
as though it were the value itself rather than a container for it. We call
these endpoint `persistent` in contrast with the next kind.

Unfortunately, assignment operators are tricky to inherit due to C++'s
automatically generated default assignment operators. For this reason, the
`persistent` type needs to be treated directly as an endpoint type (i.e. not
merely inherited), or the assignment operators need to be explictly drawn into
the derived class with a `using` declaration in public scope, e.g. `using
persistent::operator=`.

Note that we could define a specialization for the `persistent` class in case
`std::is_trivial_v<T>`; this allows us to avoid defining a move assignment
operator, and to use the slightly cheaper version of the copy assignment that
takes `T` instead of `const T&`. For now this is deemed premature optimization.

```c++
// @+'port bases'
template <typename T>
struct persistent
{
    using type = T;
    T value;
    operator T&() noexcept {return value;}
    operator const T&() const noexcept {return value;}
    auto& operator=(T&& t) noexcept {value = std::move(t); return *this;}
    auto& operator=(const T& t) noexcept {value = t; return *this;}
};
// @/

// @+'tests'
struct persistent_struct : persistent<int> {using persistent<int>::operator=;};
TEST_CASE("Persistent Value", "[ports][bases][persistent]")
{
    auto s = persistent_struct{42};
    REQUIRE(s == 42);
    s = 88;
    REQUIRE(s == 88);
    static_assert(is_aggregate_v<persistent_struct>);
}
// @/
```

## Occasional Values

Sometimes updating a value should initiate activation of the processor, and
sometimes the processor outputs values that should be propagated immediately. A
convenient way to represent this, borrowed from Avendish, is using
`std::optional` to represent the temporal semantics of these updates. The
platform is expected to clear `std::optional` valued endpoints before
activating a component so that it can signal hot outputs and recognize hot
inputs. Afterwards, the platform is expected to inspect hot outputs and take
appropriate action if any are present. An important consequence of this
semantics is that, unlike a regular value port, the state of hot outputs is not
expected to be persistent across invocations of a component, and so cannot be
used to carry state across invocations as with a regular value endpoint.
For now, we wholesale subsume `std::optional` by defining our occasional value
class as an alias for the former.

```c++
// @+'ports'
template <typename T>
using occasional = std::optional<T>;
// @/

// @+'tests'
struct occasional_struct : occasional<int> { using occasional<int>::operator=; };
TEST_CASE("Occasional Value", "[ports][bases][occasional]")
{
    auto s = occasional_struct{42};
    s = 42;
    REQUIRE(s);
    REQUIRE(s == 42);
    s = 88;
    REQUIRE(s == 88);
    auto null = occasional_struct{};
    REQUIRE(!null);
    static_assert(is_aggregate_v<occasional_struct>);
}
// @/
```

## Bang

Often an endpoint doesn't carry any value, but merely serves to convey that
an event has occurred. In Max/MSP and Pure Data, this kind of temporal
impulsive event without data is called a *bang*. We adopt the same naming
convention here.

A bang could be represented as `std::optional` of an empty type, but measurements
suggest that this actually takes more space than a `bool`, so we instead opt
to treat a persistent value port tagged with the symbol `bang` as our preferred
bang representation.

## Tags

We can introduce arbitrary symbols into the scope of a class through a bare
`enum` declaration e.g. `enum { bang };`. Our bindings can then be designed to
look for such symbols, e.g. `if constexpr (requires {port::bang;}) { ... }` and
behave depending on their presence or absence. There's no real need for a helper
class for this kind of metadata; trying to define a template class or a macro
gets cumbersome very quickly, and it's already pretty trivial to add an `enum`
to an endpoint.

# Basic Endpoints

Given the above ingredients, we now define some basic endpoints composed
from them.

```c++
// @+'ports'
template<string_literal str, bool initial_value = false>
struct _btn : named<str>, with<init{initial_value}>, with<range{false, true}> { };

template<string_literal str, bool init = false>
struct button : occasional<bool>, _btn<str, init>
{
    using occasional<bool>::operator=;
};

template<string_literal str, bool init = false>
struct toggle : persistent<bool>, _btn<str, init>
{
    using persistent<bool>::operator=;
};

template<string_literal str, init<float> initial_value = 0.0f>
struct slider : persistent<float>, named<str>, with<initial_value>, with<range{0.0f, 1.0f}>
{
    using persistent<float>::operator=;
};
// @/

// @+'tests'
TEST_CASE("Basic Ports", "[ports][basic]")
{
    static_assert(is_aggregate_v<button<"foo">>);
    static_assert(is_aggregate_v<toggle<"bar">>);
    static_assert(is_aggregate_v<slider<"baz">>);
}
// @/
```

## Bang

Often an endpoint doesn't carry any value, but merely serves to convey that
an event has occurred. In Max/MSP and Pure Data, this kind of temporal
impulsive event without data is called a *bang*. We adopt the same naming
convention here.

A bang could be represented as `std::optional` of an empty type, but
measurements suggest that this actually takes more space than a `bool`, so we
instead opt to treat a persistent value port tagged with the symbol `bang` as
our preferred bang representation; this requires us to give our bang class a
different name, but we consider this an acceptable tradeoff. We further augment
this type with a function call operator that will set the boolean value,
signalling an event has occurred.

Another possible approach would be to employ a callback semantics, so that
triggering the bang would immediately pass execution to a function registered
by the platform. For now, we opt to retain value semantics, despite callback
semantics might allow for a more space efficient implementation. Callback
semantics place a greater burden on the binding author that we would prefer to
avoid at this point.

```c++
// @+'ports'
template<string_literal str>
struct bng : persistent<bool>, named<str>
{
    using persistent<bool>::operator=;
    enum {impulse};
    void operator()() {value = true;}
};
// @/

// @+'tests'
TEST_CASE("Bang", "[ports][bang]")
{
    static_assert(is_aggregate_v<bng<"foo">>);
    auto b = bng<"foo">{};
    REQUIRE(!b);
    b();
    REQUIRE(b);
    b = {};
    REQUIRE(!b);
}
// @/
```

# Summary

```c++
// @#'ports.hpp'
#pragma once

#include <string_view>
#include <optional>
#include "utilities/consteval/consteval.hpp"

namespace sygaldry::ports
{

using namespace sygaldry;

@{port helpers}

@{port bases}

@{ports}

}
// @/

// @#'tests.cpp'

#include <catch2/catch_test_macros.hpp>
#include <string_view>
#include <type_traits>
#include <boost/pfr.hpp>
#include "ports.hpp"

using namespace sygaldry::ports;
using std::string_view;
using std::is_aggregate_v;

@{tests}
// @/
```

```cmake
# @#'CMakeLists.txt'
add_executable(ports-tests tests.cpp)
target_link_libraries(ports-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(ports-tests)
# @/
```
