# Introduction

A digital musical instrument is an assemblage of components that generate,
process, and output various forms of information with numerous different
structures and temporal characteristics. We define a *port* as a
point in the flow of data that is associated with a certain component,
and can be said to be a source or destination of data flowing through
the assemblage.

## Endpoints

Imagine we have two components, `A` and `B`, where `A` is connected directly to
`B`. We call the ports of `A` from which data originate its *source endpoints*.
These ports can generally be given descriptive names related to their
interpretation with respect to `A`, e.g. "button state" if `A` is a button, or
"saw wave" if `A` is an oscillator. From `A`'s perspective, the data coming
from these endpoints are its *outputs*. Similarly, the ports of `B` where data
arrives are its *destination endpoints*, they can be described based on their
interpretation with respect to `B`, e.g. "bypass switch" or "cutoff frequency",
and from `B`'s perspective the data arriving at these endpoints are its
*inputs*. Notice that the data that `A` sees as outputs is the same data that
`B` sees as inputs. The interpretation of endpoints depends only on the
component with which they are associated.

## Throughpoints

Now suppose the `A` and `B` are connected by an intermediary mapping `M`, such
as a preset interpolator or neural network. `M` is trained on a dataset of
examples assocating values of `A`'s sources to intended values of `B`'s
destinations. `M` automatically generates a set of ports that exactly match
`A`'s source endpoints into which data from `A` will flow into `M`, as well as
a set of ports that exactly match `B`'s destination endpoints from which data
for `B` will flow out of `M`. `M`'s ports are thus mere reflections of those of
`A` and `B`, and do not carry their own semantic interpretation or meaningful
properties. We define such ports as *throughpoints*, in contrast with
endpoints. As another example of throughpoints, imagine that data flows out of
`B` from its own source endpoints and is connected to an automatic binding `P`
that forwards this data unchanged e.g. to a network control protocol or plugin
API. `P` may also be said to have destination throughpoints matched to `B`.
Whereas the endpoints of a component have a specific interpretation,
throughpoints adapt to match certain endpoints, often all of the endpoints of
another component, based on training data, or as a binding to a different
representation of the data. The interpretation of throughpoints depends on
information from the original source or final destination of the data flowing
through the port.

# Metadata

Metadata associated with endpoints can be used to guide binding authors towards
the intended interpretation of a component. Some metadata are required, others
are optional. Considering Avendish as a point of reference, we can identify
three different kinds of metadata. There are compile-time functions, such as
the one used to get an endpoint's name. There are types with standardized names
and structures, such as a `struct range` with members `min`, `max`, and `init`.
And there are names within the scope of the endpoint (or component?) such as
those introduced by a bare `enum` declaration.

## Names

All endpoints are required to have a name. To facilitate setting this conveniently,
we define a thin wrapper around a string literal that allows us to pass string
literals as template parameters to our helpers.

```c++
// @+'ports includes'
#include <cstddef>
// @/

// @+'port helpers'
template<std::size_t N>
struct string_literal
{
    char value[N];
    consteval string_literal(const char (&str)[N]) noexcept
    {
        for (std::size_t i = 0; i < N; ++i) value[i] = str[i];
    }
};
// @/

// @+'tests'
template<string_literal str>
consteval auto name() {return string_view{str.value};}

TEST_CASE("String literal", "[ports][string_literal]")
{
    REQUIRE(string_view(string_literal{"Hello world"}.value) == "Hello world");
    REQUIRE(name<"test">() == "test");
}
// @/
```

Then we can define a class template that endpoint helpers can inherit from to
gain a name method; in general, users are anticipated to use the helpers and
not the base class, but the latter remains available for users spinning up a
custom type of endpoint.

```c++
// @+'port bases'
template<string_literal str>
struct named
{
    static consteval auto name() {return std::string_view{str.value};}
};
// @/

// @+'tests'
struct struct_with_name : named<"foo"> {};
TEST_CASE("Named", "[ports][bases][named]")
{
    REQUIRE(struct_with_name::name() == "foo");
}
// @/
```

## Range

Many endpoints have a fixed range, such as the integral 0 to 127 of MIDI
control change messages. In deviation from Avendish, we do not consider a
default initial value to be a part of the range of an endpoint, although we do
take the minimum value as the default if an explit initial value is not
specified. Similar to the `named` class, we define a helper class that
endpoints can inherit to specify their range, along with some type aliases
for the same.

```c++
// @+'port bases'
template<typename T>
concept number = std::is_integral_v<T> || std::is_floating_point_v<T>;

template<number auto _min, number auto _max>
struct ranged
{
    static consteval auto range() {
        static_assert(std::is_same_v<decltype(_min), decltype(_max)>,
                      "ranged min and max must be of same type");
        struct {
            decltype(_min) min = _min;
            decltype(_max) max = _max;
        } r;
        return r;
    }
};
// @/

// @+'port includes'
#include <type_traits>
// @/

// @+'tests'
struct struct_with_range : ranged<0, 127> {};

TEST_CASE("Ranged", "[port][bases][ranged]")
{
    REQUIRE(struct_with_range::range().min == 0);
    REQUIRE(struct_with_range::range().max == 127);
}
// @/
```

## Initial Value

As above.

```c++
// @+'port bases'
template<number auto _init>
struct initialized
{
    static consteval auto init() {return _init;}
};
// @/

// @+'tests'
struct struct_with_init : initialized<42> {};

TEST_CASE("Initialized", "[port][bases][initialized]")
{
    REQUIRE(struct_with_init::init() == 42);
}
// @/
```

# Common Endpoints

There are many common kinds of endpoints in a digital musical instrument that
vary depending on the type of data sent or received from the endpoint and the
expected temporal semantics with which that data is sent or received. Some
kinds of endpoints are more common than others, so it's convenient to define
helper types to allow instances of these endpoints to be instantiated easily
and to ensure consistency between instances of similar ports.

## Value Port

```c++
// @+'ports'
template <string_literal str, typename T>
    requires std::is_trivial_v<T>
struct value_port : named<str>
{
    using type = T;
    T value;
    operator T&() noexcept {return value;}
    operator const T&() const noexcept {return value;}
    auto& operator=(T& t) noexcept {return value = t;}
    auto& operator=(const T& t) noexcept {return value = t;}
};
// @/
```

## Toggles, Buttons, and Sliders

```c++
// @+'ports'
template<string_literal str, bool init = false>
struct toggle : public value_port<str, bool>
{
    struct range
    {
        bool min = false;
        bool max = true;
        bool init = init;
    };
};

template<string_literal str, float min, float max, 
// @/
```

# Summary

```c++
// @#'ports.hpp'
#pragma once

#include <string_view>

namespace sygaldry::ports
{

using namespace sygaldry;

@{port helpers}

@{port bases}

//@{ports}

}
// @/

// @#'tests.cpp'

#include <catch2/catch_test_macros.hpp>
#include <string_view>
#include "ports.hpp"

using namespace sygaldry::ports;
using std::string_view;

@{tests}
// @/
```

```cmake
# @#'CMakeLists.txt'
add_executable(ports-tests tests.cpp)
target_link_libraries(ports-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(ports-tests)
# @/
```
