\page page-docs-making_a_new_component Making a New Component

Copyright 2023 Travis J. West, Input Devices and Music Interaction Laboratory
(IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
(CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

SPDX-License-Identifier: MIT

[TOC]

The features and functionality provided by the Sygaldry library are almost all
implemented as reusable software components. Many new designs will require new
components to be implemented, e.g. to interface with sensors that aren't
already supported by the library, to add new binding protocols, and so on.

The skeleton of a new component can be automatically generated with \ref page-sh-new_component.
Run the script in the build environment to get started. After generating the
skeleton, continue with the rest of this document for more information on
the rationale behind the design of a Sygaldry component.

# Logical Anatomy of a Component

Logically (i.e. in terms of its logical software design, as opposed to the
physical layout of files described below) a component is simply a structure
with metadata, endpoints, and at least a `main` subroutine. The `init` and
`main` subroutines of the component will be called by the sygaldry::Runtime as
described in \ref page-sygin-making_a_new_instrument.

To make it easier to use other components and helpers from within a new
component, it should be placed within the top level `sygaldry` namespace. To
encapsulate the new component and avoid name collisions, it should be further
placed in an appropriate package namespace depending on what the component
implements and the platform-portability of the implementation. We will use the
example namespace `sygXX`

```cpp
namespace sygaldry { namespace sygXX {

struct NewComponent
: // metadata helpers here
{
    struct inputs_t {
        // input endpoints here
    } inputs;

    struct outputs_t {
        // output endpoints here
    } outputs;

    void init()
    {
        // initialization subroutine, optional
    }

    void main()
    {
        // main subroutine, required
    }
};

} }
```

## Metadata

Metadata is attached to a component (and for that matter to an endpoint) in one
of a few ways. In particular, all components must have a `static consteval auto
name()` method that returns a string. The name is expected to be title case
with spaces. An OSC address for the component is automatically generated by
replacing the spaces with underscores. It is recommended to inherit from the
sygaldry::name_ helper, as well as the related helpers described in
\ref sygah-metadata, to add other useful information such as the author and
copyright of the component, as seen in the following example:

```cpp
#include "sygah-metadata.hpp"

namespace sygaldry { namespace sygXX {

struct NewComponent
: name_<"COMPONENT NAME HERE">
, description_<"COMPONENT DESCRIPTION HERE">
, author_<"COMPONENT AUTHOR HERE">
, copyright_<"Copyright 2023 Sygaldry Contributors">
, license_<"SPDX-License-Identifier: MIT">
, version_<"0.0.0">
{
    // ...
};

} }
```

The metadata helpers are defined in the `sygaldry` namespace, so by including
our component in this namespace, we don't have to qualify the helpers names with
`sygaldry::` every time we use them.

## Endpoints

The `inputs` and `outputs` members of the component should be simple aggregate
structures. Other than this constraint, these members may contain any data
needed by the component. The `inputs` structure is not allowed to be modified
in the `main` subroutine. The `init` subroutine should set both structures to a
known initial state.

If an endpoint is self-documented appropriately, then binding components will
be able to automatically expose the endpoint, e.g. to Open Sound Control
or persistent session storage. A variety of helpers are provided to make this
easy; it is recommended to review \ref sygah-endpoints for more information.

For example, here is one way to declare a floating point input called "gain"
that goes from 0 to 10 and should be stored persistently across power cycles,
an input using the default range that is only expected to be updated sometimes
called "in", and an output array of 30 floats that is only updated when "in"
changes:

```cpp
struct inputs_t {
    slider<"gain"
          , "amount of gain applied to the input"
          , float, 0.0f¸ 10.0f, 0.0f
          , tag_session_data
          > gain;
    slider_message<"in"
          , "input to the unspecified example algorithm"
          > in;
} inputs;

struct outputs_t {
    array_message<"out", 30, "only updated when `in` changes",
                 , float
                 > out;
} outputs;
```

Like the metadata helpers, endpoint helpers are part of the `sygaldry`
namespace, so their names don't have to be fully qualified if our component is
defined in that namespace.

## Subroutines

Several subroutines are expected by the runtime. Notably, the `init` subroutine
may modify both the inputs and outputs of the component and should set them in
an initial state so that the component is ready to run, and the `main`
subroutine should implement the principal functionality of the component and update
the outputs accordingly. The `main` subroutine should not modify the inputs of
the component.

# Physical Anatomy of a Component

Physically, Sygaldry components are implemented as software components with a
uniform layout. A single `sygXX-component_name.lili.md` literate source file
generates all of the machine code required to declare (`hpp`), define (`cpp`),
and build (`CMakeLists.txt`) the component. This literate source file is placed
in a directory `sygaldry/sygXX-component_name` in the Sygaldry repository;
`sygXX` is the identifier of the package group that the component is part of
(e.g. `sygsp`), and `sygXX-component_name` is the software component
identifier. This directory is added to \ref page-docs-build_system with a call to
`add_subdirectory`, and the added `cmake` library is linked into the
appropriate submodule of the Sygaldry library.

\warning This last step is particularly important and pesky. If you forget to
add your new component to the top level build files, then it will not compile,
and you will not be able to include it in instruments or other components.
Attempting to do so will cause a compiler error to the effect that the header
file for your component could not be found, and/or a CMake error to the effect
that the library target for your component does not exist. Remember to add your
component to the build!

# Literate Anatomy of a Component

Literate programming is a fundamental part of the Sygaldry project. Every component
should be implemented in a literate source file using `lili` annotations to allow
the machine code to be extracted, include `doxygen` documentation, and have a
copyright and license statement.

## Literate Programming with lili

`lili` is a simple literate programming tool that allows machine code to be
embedded in a document in any order, and later extracted for compilation.
This is accomplished by annotating the document with simple command strings
that allow the machine code to be identified and reassembled in order.

There are three basic `lili` annotations that most authors will want to use,
two for delimiting chunks of code, and one for invoking a chunk of code defined
elsewhere.

For more documentation on `lili`, run `lili -h` from the nix shell environment,
or review [`lili`'s literate source code](https://github.com/DocSunset/lili).

### Chunk definitions

A basic code chunk definition looks like this:

```cpp
// @='chunk name'

/* body of code chunk here */

// @/
```

The sequence of characters `@=` followed by a name in quotes is recognized by
`lili` as the start of a code chunk with the given name. Anything on the line
before the `@` or after the name is ignored. Typically, this line is commented
out in the machine source language (C++ above), but this is purely aesthetic.
The entire line will never appear in the extracted machine code.

The sequence `@/` is used to mark the end of the code chunk. As with the start
of the chunk, anything else on the line where `@/` appears is ignored. By
convention, we comment out this line in the source language.

Within the document where the code chunk is defined, the chunk is always
wrapped in appropriate code-fencing syntax so that it will be syntax
highlighted when the documentation website is generated.

### Chunk invocations

When a chunk is defined anywhere in a document with `@='name'` and `@/`, it can
be invoked in another chunk definition with the sequence `@{name}`. This has
the effect of pasting the chunk in the location of the invocation. Whatever
characters preceed the `@` of the invocation are taken to be indentation, and
every line of the pasted chunk will have this indentation prepended to it.

So if we have a chunk:

```cpp
// @='child chunk'
i += 5;
// @/
```

And we invoke it:

```cpp
// @='parent chunk'
int i = 0;
int j = 0;
while (i < 20)
{
    ++j;
    @{child chunk}
}
printf("%d\n", j);
// @/
```

This should print `4`.

\warning Note that it is only allowed to invoke a chunk once. This is a
deliberate constraint on the design of `lili` to prevent "code reuse by copy
and paste" usage idioms.

### Tangle chunks

The above definition and invocation commands allow the machine code to be
presented in arbitrary order, not limited by the semantics of the compiler.
This enables the author absolute flexibility over the presentation of the
code so that they can describe the code in whatever way is hoped to be most
clear to other human readers.

The last commonly needed command is used to define a machine code document that
should be extracted from the documentation. It works in the same way as a
regular code chunk definition, but using the sequence `@#` instead of `@=`. The
name of the chunk it taken to be a filename. When `lili` is run, the text of
the chunk thus defined, with any chunk invocations expanded recursively, will
be written to a file with that name, in the same directory as the `lili` source
file. This process is called "tangling" the machine source, which by analogy
exists in an un-tangled state woven through the literate source prose.

## Doxygen Documentation

As well as the literate source code, components should be further annotated
with `doxygen` comments. Components should also be nested within appropriate
`doxygen` groups corresponding to their package namespace and software
component identifier. Components should also have a `doxygen` `\page` command
at the top of the file, where the page name is `page-sygXX-component_name`,
i.e. the software component identifier prepended with `page-`, and the title of
the page begins with the software component identifier, as in
`sygXX-component_name: Page Title`. The page title is often simply the name of
the component. While this is all terribly redundant, it's necessary so that the
documentation website will include the software component identifier in the
page title so that users reading the documentation can unambiguously make this
important association.

## Copyright and License Text

Finally, all source files (both literate and machine) must have a copyright
statement and license identifier at the top of the file, as seen in all
documents in the repository. Contributors are welcome to use whatever license
they feel is appropriate, although MIT is encouraged for consistency when
allowed.
