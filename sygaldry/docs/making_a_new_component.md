\page page-docs-making_a_new_component Making a New Component

Copyright 2023 Travis J. West, Input Devices and Music Interaction Laboratory
(IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
(CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

SPDX-License-Identifier: MIT

[TOC]

The features and functionality provided by the Sygaldry library are almost all
implemented as reusable software components. Many new designs will require new
components to be implemented, e.g. to interface with sensors that aren't
already supported by the library, to add new binding protocols, and so on.

# Logical Anatomy of a Component

Logically (i.e. in terms of its logical software design, as opposed to the
physical layout of files described below) a component is simply a structure
with metadata, endpoints, and at least a `main` subroutine. The `init` and
`main` subroutines of the component will be called by the sygaldry::Runtime as
described in \ref page-sygin-making_a_new_instrument.

To make it easier to use other components and helpers from within a new
component, it should be placed within the top level `sygaldry` namespace. To
encapsulate the new component and avoid name collisions, it should be further
placed in an appropriate package namespace depending on what the component
implements and the platform-portability of the implementation. We will use the
example namespace `sygXY`

```cpp
namespace sygaldry { namespace sygXY {

struct NewComponent
: // metadata helpers here
{
    struct inputs_t {
        // input endpoints here
    } inputs;

    struct outputs_t {
        // output endpoints here
    } outputs;

    void init()
    {
        // initialization subroutine, optional
    }

    void main()
    {
        // main subroutine, required
    }
};

} }
```

## Metadata

Metadata is attached to a component (and for that matter to an endpoint) in one
of a few ways. In particular, all components must have a `static consteval auto
name()` method that returns a string. The name is expected to be title case
with spaces. An OSC address for the component is automatically generated by
replacing the spaces with underscores. It is recommended to inherit from the
sygaldry::name_ helper, as well as the related helpers described in
\ref sygah-metadata, to add other useful information such as the author and
copyright of the component, as seen in the following example:

```cpp
#include "sygah-metadata.hpp"

namespace sygaldry { namespace sygXY {

struct NewComponent
: name_<"COMPONENT NAME HERE">
, description_<"COMPONENT DESCRIPTION HERE">
, author_<"COMPONENT AUTHOR HERE">
, copyright_<"Copyright 2023 Sygaldry Contributors">
, license_<"SPDX-License-Identifier: MIT">
, version_<"0.0.0">
{
    // ...
};

} }
```

The metadata helpers are defined in the `sygaldry` namespace, so by including
our component in this namespace, we don't have to qualify the helpers names with
`sygaldry::` every time we use them.

## Endpoints

The `inputs` and `outputs` members of the component should be simple aggregate
structures. Other than this constraint, these members may contain any data
needed by the component. The `inputs` structure is not allowed to be modified
in the `main` subroutine. The `init` subroutine should set both structures to a
known initial state.

If an endpoint is self-documented appropriately, then binding components will
be able to automatically expose the endpoint, e.g. to Open Sound Control
or persistent session storage. A variety of helpers are provided to make this
easy; it is recommended to review \ref sygah-endpoints for more information.

For example, here is one way to declare a floating point input called "gain"
that goes from 0 to 10 and should be stored persistently across power cycles,
an input using the default range that is only expected to be updated sometimes
called "in", and an output array of 30 floats that is only updated when "in"
changes:

```cpp
struct inputs_t {
    slider<"gain"
          , "amount of gain applied to the input"
          , float, 0.0f¸ 10.0f, 0.0f
          , tag_session_data
          > gain;
    slider_message<"in"
          , "input to the unspecified example algorithm"
          > in;
} inputs;

struct outputs_t {
    array_message<"out", 30, "only updated when `in` changes",
                 , float
                 > out;
} outputs;
```

Like the metadata helpers, endpoint helpers are part of the `sygaldry`
namespace, so their names don't have to be fully qualified if our component is
defined in that namespace.

## Subroutines

Several subroutines are expected by the runtime. Notably, the `init` subroutine
may modify both the inputs and outputs of the component and should set them in
an initial state so that the component is ready to run, and the `main`
subroutine should implement the principal functionality of the component and update
the outputs accordingly. The `main` subroutine should not modify the inputs of
the component.

# Physical Anatomy of a Component

Physically, Sygaldry components are implemented as software components with a
uniform layout. A single `sygXY-component_name.lili.md` literate source file
generates all of the machine code required to declare (`hpp`), define (`cpp`),
and build (`CMakeLists.txt`) the component. This literate source file is placed
in a directory `sygaldry/sygXY-component_name` in the Sygaldry repository;
`sygXY` is the identifier of the package group that the component is part of
(e.g. `sygsp`), and `sygXY-component_name` is the software component
identifier. This directory is added to `build-system.lili.md` with a call to
`add_subdirectory`, and the added `cmake` library is linked into the
appropriate submodule of the Sygaldry library.

# Documentation

Literate programming is a fundamental part of the Sygaldry project. Every component
should be implemented in a literate source file using `lili` annotations to allow
the machine code to be extracted.

As well as the literate source code, components should be further annotated
with `doxygen` comments. Components should also be nested within appropriate
`doxygen` groups corresponding to their package namespace and software
component identifier. Components should also have a `doxygen` `\page` command
at the top of the file, where the page name is `page-sygXY-component_name`, i.e.
the software component identifier prepended with `page-`.

Finally, all source files (both literate and machine) must have a copyright
statement and license identifier at the top of the file, as seen in all
documents in the repository. Contributors are welcome to use whatever license
they feel is appropriate, although MIT is encouraged for consistency when
allowed.

```cpp
\page page-sygXY-component_name

namespace sygaldry { namespace sygXY {

/*! \addtogroup sygsp
*/
/// \{

/*! \defgroup sygsp-mimu_fusion MIMU Sensor Fusion
*/
/// \{

/*! Brief desxcription

Detailed description
*/
struct NewComponent
{
    // ...

    /*! Subroutine description

    detailed description

    \param[in,out] p param documentation
    etc
    */
    void main(int p) { /* ... */ }
};

/// \}
/// \}

} }
```

# Template

A template file for a new component is provided at `sygaldry/docs/template.md`,
also viewable [here](\ref page-sygXY-new_component).

\subpage page-sygXY-new_component
