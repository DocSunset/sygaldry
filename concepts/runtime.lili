# Runtime

The runtime describes the expected behavior of the host platform of an
assemblage of components. The runtime must first call every component's `init`
method, if it has one. Then, in an endless loop, each component's main
subroutine must be called, in node-tree-order, except for components which are
parts in a subassembly with its own main subroutine. Between main ticks, all of
the clearable flag endpoints should be cleared appropriately: input flags
should be cleared before beginning the tick, and output flags should be cleared
after it has resolved. Plugins and throughpoints should be automatically
propagated to components that need them by extracting them from the assemblage.

TODO: COPYRIGHT AND LICENSE NOTICE HERE

# Design Rationale

Originally planned as further overloads of the the `init` and `activate`
functions in [the components concepts library](concepts/components.lili.md),
the runtime class below allows the plugins and throughpoints of components
having them to be automatically extracted by type from a component container
when calling the `init` and `activate` methods of components. The decision was
made to construct this as a class in order to ensure that the compiler would
have the best chance of computing the argument extraction at compile time. It
is a kind of ultimate binding that is meant to drive all other components,
including binding components. The runtime is included in the concepts library
so that components in the components library may make use of it to simplify
their implementation using parts.

# Example

```cpp
// @+'tests'
template<string_literal str>
struct testcomponent1_t : name_<str>
{
    struct inputs_t {
        struct in1_t {
            int value;
        } in1;
    } inputs;

    struct outputs_t {
        struct out1_t {
            int value;
        } out1;
        bng<"bang out"> bang_out;
    } outputs;

    void init() { inputs.in1.value = 42; }
    void main()
    {
        outputs.out1.value = inputs.in1.value + 1;
        CHECK(false == (bool)outputs.bang_out); // output flags are clear on entry to main
        outputs.bang_out();
        CHECK(true == (bool)outputs.bang_out);
    }
};

struct testcomponent2_t : name_<"tc2">
{
    struct outputs_t {
        struct out1_t {
            int value;
        } out1;
        struct out2_t {
            int value;
        } out2;
    } outputs;

    struct parts_t {
        testcomponent1_t<"part"> part;
    } parts;

    void init() {};

    void main(const testcomponent1_t<"tc1">::outputs_t& sources, testcomponent1_t<"tc1">& plugin)
    {
        CHECK(true == (bool)plugin.outputs.bang_out); // flags propagate during main tick
        outputs.out1.value = sources.out1.value + 1;
        outputs.out2.value = plugin.outputs.out1.value + 1;
    }
};

struct components1_t
{
    testcomponent1_t<"tc1"> tc1;
    testcomponent2_t tc2;
};
// @/

// @+'tests'
constinit components1_t components{};
constexpr auto runtime = Runtime{components};
TEST_CASE("runtime calls")
{
    runtime.init();
    CHECK(runtime.container.tc1.inputs.in1.value == 42); // init routines are called
    CHECK(runtime.container.tc2.parts.part.inputs.in1.value == 0); // part inits are not called
    runtime.main();
    CHECK(false == (bool)runtime.container.tc1.outputs.bang_out); // out flags are clear after call to main
    CHECK(runtime.container.tc1.outputs.out1.value == 43); // main routines are called
    CHECK(runtime.container.tc2.outputs.out1.value == 44); // throughpoints are propagated
    CHECK(runtime.container.tc2.outputs.out2.value == 44); // plugins are propagated
                                                            // calls proceed in tree order
    CHECK(runtime.container.tc2.parts.part.outputs.out1.value == 0); // part mains are not called
}
// @/
```

# Implementation

## Extracting Plugins and Components

Arguably the trickiest aspect of the runtime's responsibilities is to recognize what
arguments a component's subroutine requires, extract them from the assemblage, and
apply them to the subroutine. We would like to ensure that this happens efficiently,
meaning without runtime traversal of the component tree derived from the assemblage.

```cpp
TEST_CASE("example test")
{
    components1_t components;
    components.tc1.inputs.in1.value = 0;
    components.tc1.outputs.bang_out();
    activate(components.tc2, components); // << this should compile to something like:
                       // components.tc2.main(components.tc1.outputs, components.tc1);
    CHECK(components.tc2.outputs.out1.value == 1);
}
```

### Use a fold

My first attempt resembled the following. A template struct whose type parameters give
the (cvref removed) types of the arguments to a component to activate. In the `activate`
method of this structure, these type parameters are unpacked to into `find` to locate
the entities with the given types in the component tree. This `runtime_impl` struct is
then instantiated with the appropriate arguments using our function reflection facilities
and a bit of template metaprogramming provided by `mp11`.

```cpp
template<typename ... Args>
struct runtime_impl
{
    template <typename Component, typename ComponentContainer>
    static void activate(Component& component, ComponentContainer& container)
    {
        if constexpr (requires {&Component::operator();})
            component(find<Args>(container) ...);
        else if constexpr (requires {&Component::main;})
            component.main(find<Args>(container) ...);
    }
};

template<typename Component, typename ComponentContainer>
void activate(Component& component, ComponentContainer& container)
{
    using args = typename main_subroutine_reflection<Component>::arguments;
    using runtime = boost::mp11::mp_rename<boost::mp11::mp_transform<std::remove_cvref_t, args>, runtime_impl>;
    runtime::activate(component, container);
}
```

### Traverse at compile time

Unfortunately, the compiler is unable to optimize away the traversal of the
component tree implied by the multiple calls to `find` in this implementation.
We need some way of declaring this traversal `constexpr`, or perhaps
`constinit`. This lead to the following implementation. Roughly the same
metaprogramming pattern is used to enable the arguments of the function to be
extracted by expanding a parameter pack into `find` calls. However, instead of
doing so in a function call context, a tuple is `constexpr` initialized which
holds the arguments until call time. This structure can be declared
`constinit`, which should guarantee that the construction of the arguments
tuple, and thus the traversal of the component tree, happens at compile time;
in case the compile didn't compute this for some reason, there would still be
no runtime performance impact, as the traversal would take place before the
main program properly started running. The only drawback in this case, which
should be impossible anyways, would be a likely increase in compiled executable
code size.

```cpp
// @+'tests'
components1_t constinit main_runtime_components{};
component_runtime<testcomponent2_t, components1_t> constinit main_component_runtime{main_runtime_components.tc2, main_runtime_components};
TEST_CASE("component runtime main")
{
    main_runtime_components.tc1.outputs.out1.value = 0;
    main_runtime_components.tc1.outputs.bang_out();
    main_component_runtime.main();
    CHECK(main_runtime_components.tc2.outputs.out1.value == 1);
    CHECK(main_runtime_components.tc2.outputs.out2.value == 1);
}
// @/
```

```cpp
// @='component_runtime 1'
template<typename Component, typename ComponentContainer, typename ... Args>
struct component_runtime_impl
{
    using arg_pack_t = decltype(std::forward_as_tuple(find<Args>(std::declval<ComponentContainer&>())...));
    const arg_pack_t arg_pack;

    constexpr component_runtime_impl(ComponentContainer& container) : arg_pack{std::forward_as_tuple(find<Args>(container) ...)} {}

    void main(Component& component) const
    {
        if constexpr (requires {&Component::operator();})
            std::apply(component, arg_pack);
        else if constexpr (requires {&Component::main;})
            std::apply([&](auto& ... args) {component.main(args...);}, arg_pack);
    }
};

template<typename Component, typename ComponentContainer>
struct component_runtime
{
    using args = typename main_subroutine_reflection<Component>::arguments;
    using cvref_less_args = boost::mp11::mp_transform<std::remove_cvref_t, args>;
    using prepended = boost::mp11::mp_push_front<cvref_less_args, Component, ComponentContainer>;
    using impl_t = boost::mp11::mp_rename<prepended, component_runtime_impl>;

    Component& component;
    const impl_t impl;
    constexpr component_runtime(Component& comp, ComponentContainer& cont) : component{comp}, impl{cont} {};

    void init() const
    {
        // TODO
    };

    void main() const
    {
        impl.main(component);
    };
};
// @/
```

### Generalize

The above implementation is only able to activate a single component. It is
reasonably straightforward to generalize this to both initialize and activate
an arbitrary number of components held in a component container.

First, we pull out the argument pack used in the inner implementation:

```cpp
// @='impl_arg_pack'
template<typename ComponentContainer, typename ... Args>
struct impl_arg_pack
{
    using arg_pack_t = decltype(std::forward_as_tuple(find<Args>(std::declval<ComponentContainer&>())...));
    const arg_pack_t pack;

    constexpr impl_arg_pack(ComponentContainer& container) : pack{std::forward_as_tuple(find<Args>(container) ...)} {}
};
// @/
```

Then, we generalize the innermost implementation structure so that it can
initialize or activate a component, accepting argument packs for both of
these subroutines.

```cpp
// @='runtime_impl'
@{impl_arg_pack}

template<typename Component, typename ComponentContainer, typename init_arg_pack, typename main_arg_pack>
struct runtime_impl
{
    init_arg_pack init_args;
    main_arg_pack main_args;

    constexpr runtime_impl(ComponentContainer& container) : init_args{container}, main_args{container} {}

    void init(Component& component) const
    {
        if constexpr (requires {&Component::init;})
            std::apply([&](auto& ... args) {component.init(args...);}, init_args.pack);
    }

    void main(Component& component) const
    {
        if constexpr (requires {&Component::operator();})
            std::apply(component, main_args.pack);
        else if constexpr (requires {&Component::main;})
            std::apply([&](auto& ... args) {component.main(args...);}, main_args.pack);
    }
};
// @/
```

We can reimplement the original component_runtime in terms of the new runtime implementation,
and the above test passes without issue. We can additionally test the runtime's ability to run
the init method.

```cpp
// @+'tests'
components1_t constinit init_runtime_components{};
component_runtime<testcomponent1_t<"tc1">, components1_t> constinit init_component_runtime{init_runtime_components.tc1, init_runtime_components};
TEST_CASE("component runtime init")
{
    init_runtime_components.tc1.inputs.in1.value = 0;
    init_component_runtime.init();
    CHECK(init_runtime_components.tc1.inputs.in1.value == 42);
}
// @/

// @='component_runtime 2'
@{runtime_impl}

template<typename Component, typename ComponentContainer>
struct component_runtime
{
    using init_args = typename init_subroutine_reflection<Component>::arguments;
    using init_cvref_less_args = boost::mp11::mp_transform<std::remove_cvref_t, init_args>;
    using init_prepended = boost::mp11::mp_push_front<init_cvref_less_args, ComponentContainer>;
    using init_arg_pack = boost::mp11::mp_rename<init_prepended, impl_arg_pack>;

    using main_args = typename main_subroutine_reflection<Component>::arguments;
    using main_cvref_less_args = boost::mp11::mp_transform<std::remove_cvref_t, main_args>;
    using main_prepended = boost::mp11::mp_push_front<main_cvref_less_args, ComponentContainer>;
    using main_arg_pack = boost::mp11::mp_rename<main_prepended, impl_arg_pack>;

    Component& component;
    const runtime_impl<Component, ComponentContainer, init_arg_pack, main_arg_pack> impl;
    constexpr component_runtime(Component& comp, ComponentContainer& cont) : component{comp}, impl{cont} {};

    void init() const { impl.init(component); } 
    void main() const { impl.main(component); };
};
// @/
```

To avoid repeating the series of template metafunctions used to get the
argument pack types, we define a helper template that takes a function
reflection structure and returns an appropriate argument pack. We allow this to
return a dummy arg pack in case a component lacks an init or main subroutine,
so that components missing one or the other will not trigger a compiler error.

```cpp
// @='to_arg_pack'
template<typename...>
struct to_arg_pack
{
    struct dummy_t {
        std::tuple<> pack;
        constexpr dummy_t(auto&) : pack{} {};
    };
    using pack_t = dummy_t;
};

template<typename Component, typename ComponentContainer, typename FuncRefl>
    requires FuncRefl::exists::value
struct to_arg_pack<Component, ComponentContainer, FuncRefl>
{
    using args = typename FuncRefl::arguments;
    using cvref_less = boost::mp11::mp_transform<std::remove_cvref_t, args>;
    using prepended = boost::mp11::mp_push_front<cvref_less, ComponentContainer>;
    using pack_t = boost::mp11::mp_rename<prepended, impl_arg_pack>;
};
// @/
```

We use this helper to get two argument pack types, one for init and one for
main, that are then used to instantiate the runtime structure. We thus have a
general runtime for a single component that passes our tests.

```cpp
//@='component_runtime'
@{runtime_impl}

@{to_arg_pack}

template<typename Component, typename ComponentContainer>
struct component_runtime
{
    using init_arg_pack = typename to_arg_pack<Component, ComponentContainer, init_subroutine_reflection<Component>>::pack_t;
    using main_arg_pack = typename to_arg_pack<Component, ComponentContainer, main_subroutine_reflection<Component>>::pack_t;

    Component& component;
    const runtime_impl<Component, ComponentContainer, init_arg_pack, main_arg_pack> impl;
    constexpr component_runtime(Component& comp, ComponentContainer& cont) : component{comp}, impl{cont} {};

    void init() const { impl.init(component); }
    void main() const { impl.main(component); };
};
// @/
```

### Tuple of runtimes

All that remains is to make a tuple of component runtimes with one for each
runtime managed component in the component tree. First we define a subroutine
that will give us a tuple of runtimes.

```cpp
// @='runtime tuple'
template<typename ComponentContainer>
constexpr auto component_to_runtime_tuple(ComponentContainer& cont)
{
    auto tup = component_filter_by_tag<node::component>(cont);
    return boost::mp11::tuple_transform([&](auto& tagged_component)
    {
        return component_runtime{tagged_component.ref, cont};
    }, tup);
}
// @/

// @+'tests'
components1_t constinit runtime_tuple_components{};
constexpr auto runtime_tuple = component_to_runtime_tuple(runtime_tuple_components);
TEST_CASE("runtime tuple")
{
    std::apply([](auto& ... runtime) {(runtime.init(), ...);}, runtime_tuple);
    CHECK(runtime_tuple_components.tc1.inputs.in1.value == 42); // init routines are called
    std::apply([](auto& ... runtime) {(runtime.main(), ...);}, runtime_tuple);
    CHECK(runtime_tuple_components.tc1.outputs.out1.value == 43); // main routines are called
}
// @/
```

Then we can assemble the final runtime class. This requires a somewhat awkward
repetition of the call to `component_to_runtime_tuple`, first to get the type
of the tuple and then to actually initialize it. Otherwise, the top level
runtime simply delegates to the inner component runtimes.

```cpp
// @='Runtime'
template<typename ComponentContainer>
struct Runtime
{
    ComponentContainer& container;

    decltype(component_to_runtime_tuple(std::declval<ComponentContainer&>())) component_runtimes;

    constexpr Runtime(ComponentContainer& c) : container{c}, component_runtimes{component_to_runtime_tuple(c)} {};

    void init() const { tuple_for_each(component_runtimes, [](auto& r){r.init();}); }
    void main() const
    {
        tuple_for_each(component_runtimes, [](auto& r){r.main();});
        tuple_for_each(component_runtimes, [](auto& r)
        {
            clear_input_flags(r.component);
            clear_output_flags(r.component);
        });
    }
};
// @/
```

# Runtime summary

```cpp
// @#'runtime.hpp'
#pragma once

#include <boost/mp11.hpp>
#include "concepts/functions.hpp"
#include "concepts/components.hpp"
#include <iostream>

namespace sygaldry {

@{component_runtime}

@{runtime tuple}

@{Runtime}

}
// @/

// @#'tests/runtime/tests.cpp'
#include <catch2/catch_test_macros.hpp>
#include "concepts/runtime.hpp"
#include "helpers/endpoints.hpp"

using namespace sygaldry;

@{tests}
// @/
```

```cmake
# @#'tests/runtime/CMakeLists.txt'
add_executable(runtime-tests tests.cpp)
target_link_libraries(runtime-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(runtime-tests)
# @/
```
