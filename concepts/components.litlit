# Components Concepts

We consider two kinds of components: regular components and pure assemblies.

```c++
// @='Component'
template<typename T>
concept Component = RegularComponent<T> || PureAssembly<T>;
// @/
```

A regular component has a name, a main subroutine, and at least one of
endpoints, throughpoints, parts, or plugins.

```c++
// @='RegularComponent'
template<typename T>
concept RegularComponent = has_main_subroutine<T> && has_name<T> &&
        ( has_inputs<T> || has_outputs<T> || has_parts<T>
        // TODO || has_throughpoints<T> || has_plugins<T>
        );
// @/
```

A pure assembly has only parts, no inputs or outputs, and no main subroutine,
and it is not required to have a name. A pure assembly may also be represented
by a simple aggregate struct of endpoints.

```c++
// @='PureAssembly'
template<typename T>
concept PureAssembly = (is_simple_aggregate<T> && has_only_endpoints<T>) ||
    ( has_parts<T> && not ( has_main_subroutine<T>
    || has_inputs<T> || has_outputs<T>
    // TODO || has_throughpoints<T> || has_plugins<T>
    ) );
// @/
```

```c++
// @+'tests'

struct my_component_t : name_<"component concept test component">
{
    struct inputs_t {} inputs;
    struct outputs_t {} outputs;
    struct parts_t {} parts;
    static void main(const inputs_t&, outputs_t&) {}
};

struct struct_of_components
{
    my_component_t component;
};

TEST_CASE("Base Component Concepts")
{
    SECTION("has ___")
    {
        // static_assert(has_main_subroutine<my_component_t>);
        // static_assert(has_inputs<my_component_t>);
        // static_assert(has_outputs<my_component_t>);
        // static_assert(has_parts<my_component_t>);
        // static_assert(has_parts<my_component_t>);
        // TODO static_assert(has_throughpoints<my_component_t>);
        // TODO static_assert(has_plugins<my_component_t>);
        // static_assert(has_only_endpoints<struct_of_components>);
        // static_assert(is_simple_aggregate<struct_of_components>);
    }
}
// @/

// @='base component concepts'
@{base component implementation details}

//@{RegularComponent}
//
//@{PureAssembly}
//
//@{Component}
template<typename T>
concept Component = requires (T t) {t.inputs; t.outputs;};
// @/
```

## Component Concepts Implementation

Using our small [function reflection library](concepts/functions.litlit) we can
tell whether a component has a main subroutine by checking whether the return
type of the expected methods (`T::main` or `T::operator()`) have the expected
type (void). This concept will not be satisfied if `T::main` is a variable,
since function reflection is impossible in this case and checking the return
type is thus an error.

```c++
// @+'base component implementation details'
template<typename T>
concept has_main_subroutine
    =  std::same_as<void, typename function_reflection<&T::operator()>::return_type>
    || std::same_as<void, typename function_reflection<&T::main>::return_type>
    ;
// @/

// @+'tests'
struct void_main { void main() {} };
struct void_operator { void operator()() {} };
static_assert(has_main_subroutine<void_main>);
static_assert(has_main_subroutine<void_operator>);

struct member_main { int main; };
struct int_main { int main() {return 1;} };
struct int_operator { int operator()() {return 1;} };
static_assert(!has_main_subroutine<member_main>);
static_assert(!has_main_subroutine<int_main>);
static_assert(!has_main_subroutine<int_operator>);
// @/
```

Many components have endpoints with message semantics, e.g. by its value having
semantics similar to a pointer or `std::optional`. These values are expected to
be cleared so that they have a `false` interpretation unless the value has been
set just before or during the current call to the component's main subroutine.
To facilitate bindings implementing this behavior in a consistent way, the
following subroutine is implemented, that reflects over a component's endpoints
and clears all of its endpoints with this semantics.

A test is not provided for this function here, since its use in the CLI binding
is well tested.

```c++
// @#'components.hpp'
#pragma once

#include <boost/pfr.hpp>
#include "concepts/functions.hpp"
#include "concepts/endpoints.hpp"

namespace sygaldry { namespace concepts {

@{base component concepts}

template<Component T>
auto& inputs_of(T& component)
{
    return component.inputs;
};

template<Component T>
auto& outputs_of(T& component)
{
    return component.outputs;
};

template<typename T>
void clear_flags(T& entities)
{
    if constexpr (Component<T>)
    {
        clear_flags(inputs_of(entities));
        clear_flags(outputs_of(entities));
    }
    else
    {
        boost::pfr::for_each_field(entities, []<typename Y>(Y& endpoint)
        {
            if constexpr (ClearableFlag<Y>) clear_flag(endpoint);
        });
    }
}

template<Component T>
void activate(T& component)
{
    clear_flags(outputs_of(component));
    if constexpr (requires {component.main(component.inputs, component.outputs);})
        component.main(component.inputs, component.outputs);
    else if constexpr (requires {component(component.inputs, component.outputs);})
        component(component.inputs, component.outputs);
    else if constexpr (requires {component();})
        component();
    clear_flags(inputs_of(component));
}

} }
// @/
```

```c++
// @#'tests/components/tests.cpp'
#include <type_traits>
#include <catch2/catch_test_macros.hpp>
#include "helpers/metadata.hpp"
#include "concepts/components.hpp"

using namespace sygaldry::concepts;
using namespace sygaldry::helpers;

@{tests}
// @/
```

```cmake
# @#'tests/components/CMakeLists.txt'
add_executable(components-concepts-tests tests.cpp)
target_link_libraries(components-concepts-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(components-concepts-tests)
# @/
```
