# Components Concepts

We consider three kinds of components: regular components, assemblies,
and containers.

```c++
// @='Component'
template<typename T>
concept Component = RegularComponent<T> || Assembly<T> || Container<T>;
// @/
```

A regular component has a name, a main subroutine, and at least one of
endpoints, throughpoints, parts, or plugins.

```c++
// @='RegularComponent'
template<typename T>
concept RegularComponent = has_main_subroutine<T> && has_name<T> &&
        ( has_inputs<T> || has_outputs<T> || has_parts<T>
        // TODO || has_throughpoints<T> || has_plugins<T>
        );
// @/

// @+'tests'
struct my_component_t : name_<"component concept test component">
{
    struct inputs_t {} inputs;
    struct outputs_t {} outputs;
    struct parts_t {} parts;
    static void main(const inputs_t&, outputs_t&) {}
} my_component;

static_assert(has_main_subroutine<my_component_t>);
static_assert(has_inputs<my_component_t>);
static_assert(has_outputs<my_component_t>);
static_assert(has_parts<my_component_t>);
static_assert(RegularComponent<my_component_t>);
static_assert(Component<my_component_t>);
// @/
```

An assembly has only parts, no inputs or outputs, and no main subroutine,
and it is not required to have a name.

```c++
// @='Assembly'
template<typename T>
concept Assembly
    =  has_parts<T> && not ( has_main_subroutine<T>
    || has_inputs<T> || has_outputs<T>)
    // TODO || has_throughpoints<T> || has_plugins<T>
    ;
// @/

// @+'tests'
struct component_of_parts : name_<"component concept test assembly">
{
    struct parts_t {
        my_component_t component;
    } parts;
} my_assembly2;

static_assert(has_parts<component_of_parts>);
static_assert(not has_main_subroutine<component_of_parts>);
static_assert(not has_inputs<component_of_parts>);
static_assert(not has_outputs<component_of_parts>);
static_assert(Assembly<component_of_parts>);
//static_assert(Component<component_of_parts>);

// @/
```

A container is merely an aggregate that contains only assemblies and/or regular
components.

```c++
// @='Container'
template<typename T>
concept Container = Aggregate<T> && has_only_components<T>;
// @/

// @+'tests'
struct struct_of_components
{
    my_component_t component1;
    component_of_parts component2;
} my_assembly1;

static_assert(Aggregate<struct_of_components>);
static_assert(has_only_components<struct_of_components>);
static_assert(Container<struct_of_components>);
//static_assert(Component<struct_of_components>);
// @/
```

```c++
// @='base component concepts'
@{base component implementation details}

@{RegularComponent}

@{Assembly}

@{Container}

//@{Component}
template<typename T>
concept Component = requires (T t) {t.inputs; t.outputs;};
// @/
```

## Component Concepts Implementation

To detect whether a component has parts, inputs, or outputs, we employ the same
structure parameterized on the expected name of the nested simple aggregate
structure. We use a macro to avoid repetition. A similar pattern is used
[to define `has_name`](concepts/metadata.litlit).

```c++
// @+'base component implementation details'
#define has_type_or_value(NAME)\
template<typename T> concept has_##NAME##_member = requires (T t) { t.NAME; };\
template<typename T> concept has_##NAME##_type = requires { typename T::NAME; };\
template<typename T> concept has_##NAME##_t = requires { typename T::NAME##_t; };\
template<typename T>\
concept has_##NAME \
    =  has_##NAME##_member<T>\
    || has_##NAME##_type<T>\
    || has_##NAME##_t<T>;\
\
template<typename T> requires has_##NAME##_member<T> auto& NAME##_of(T& t) { return t.NAME; }\
template<typename T> requires has_##NAME##_member<T> const auto& NAME##_of(const T& t) { return t.NAME; }

has_type_or_value(inputs);
has_type_or_value(outputs);
has_type_or_value(parts);

#undef has_type_or_value
// @/

// @+'tests'
static_assert(std::same_as<my_component_t::inputs_t&, decltype(inputs_of(my_component))>);
static_assert(std::same_as<my_component_t::outputs_t&, decltype(outputs_of(my_component))>);
static_assert(std::same_as<my_component_t::parts_t&, decltype(parts_of(my_component))>);
// @/
```

Using our small [function reflection library](concepts/functions.litlit) we can
tell whether a component has a main subroutine by checking whether the return
type of the expected methods (`T::main` or `T::operator()`) have the expected
type (void). This concept will not be satisfied if `T::main` is a variable,
since function reflection is impossible in this case and checking the return
type is thus an error.

```c++
// @+'base component implementation details'
template<typename T>
concept has_main_subroutine
    =  std::same_as<void, typename function_reflection<&T::operator()>::return_type>
    || std::same_as<void, typename function_reflection<&T::main>::return_type>
    ;
// @/

// @+'tests'
struct void_main { void main() {} };
struct void_operator { void operator()() {} };
static_assert(has_main_subroutine<void_main>);
static_assert(has_main_subroutine<void_operator>);

struct member_main { int main; };
struct int_main { int main() {return 1;} };
struct int_operator { int operator()() {return 1;} };
static_assert(not has_main_subroutine<member_main>);
static_assert(not has_main_subroutine<int_main>);
static_assert(not has_main_subroutine<int_operator>);
// @/
```

## Simple Aggregate

Our notion of a simple aggregate comes from `boost::pfr`, which we rely on for
the ability to iterate over lists of endpoints and components in the form of
structures, an essential functionality for our purposes. We would ideally defer
to `boost::pfr` for our test of simple aggregate requirements, but a straightforward
concept--

```c++
template<typename T>
concept Aggregate = requires { boost::pfr::tuple_size_v<T>; };

```

--does not provide the required results. It appears as though the compiler
considers this to be a valid expression regardless of the result, even if pfr
itself would raise several static assertion failures with the given `T`.

Attempts to defer to `std::is_aggregate_v<T>` in a similar fashion were also
unsatisfactory, with various test structures passing the test even through
`boost::pfr` rejects them at compile time through static assertions. It doesn't
help that `boost::pfr`'s implementation and documentation don't always agree on
what the requirements are:

```c++
// @+'tests'
// docs say: aggregates may not have base classes
struct foo { int x; foo(int a, int b) : x{a+b} {} };
struct not_simple_aggregate1 : foo { };
static_assert(std::is_aggregate_v<not_simple_aggregate1>); // passes
// auto failure = boost::pfr::tuple_size_v<not_simple_aggregate1>; // static assertion failure

// docs say: aggregates may not have const fields
struct not_simple_aggregate2 { const int i; };
static_assert(std::is_aggregate_v<not_simple_aggregate2>); // passes
static_assert(1 == boost::pfr::tuple_size_v<not_simple_aggregate2>); // works fine, even though the docs say it's not allowed

// docs say: aggregates may not have reference fields
struct not_simple_aggregate3 { int& i; };
static_assert(std::is_aggregate_v<not_simple_aggregate3>); // passes
static_assert(1 == boost::pfr::tuple_size_v<not_simple_aggregate3>); // works fine, even though the docs say it's not allowed

// docs say: aggregates may not have c arrays
struct not_simple_aggregate4 { float f; int i[5]; };
static_assert(std::is_aggregate_v<not_simple_aggregate4>); // passes
static_assert(6 == boost::pfr::tuple_size_v<not_simple_aggregate4>); // works fine, even though the docs say it's not allowed, although arguably this should return 2?

// docs say: aggregates may not have constructors
struct not_simple_aggregate5 { float f; not_simple_aggregate5(float a, float b) : f{a + b} {} };
static_assert(not std::is_aggregate_v<not_simple_aggregate5>); // a class with a constructor is not aggregate
//auto failure = boost::pfr::tuple_size_v<not_simple_aggregate5>; // static assertion failure

// docs don't mention scalars, but implementation suggests they're fine
using not_simple_aggregate6 = float;
static_assert(not std::is_aggregate_v<not_simple_aggregate6>); // a float is not aggregate
static_assert(std::is_scalar_v<not_simple_aggregate6>); // a float is scalar
static_assert(1 == boost::pfr::tuple_size_v<not_simple_aggregate6>); // works, in accordance with the docs

// docs say: unions not allowed
union not_simple_aggregate7 {float f; int i;} nope;
static_assert(std::is_aggregate_v<not_simple_aggregate7>); // passes
// auto failure = boost::pfr::structure_to_tuple(nope); // static assertion failure
// @/
```

In most cases, `boost::pfr` seems to work when `std::is_aggregate_v` is true,
and to fail when it is not. The only exceptions we noted in our tests are when
`T` is scalar, such as a single `float`, when `T` is a union, and when `T` has
any base class. We can easily detect when `T` is scalar or union using
`std::is_scalar` and `std::is_union` respectively. However, it is challenging
to detect when `T` has a base class. For now, we defer this issue to
`boost::pfr`, which will in any case raise a static assertion failure if we try
to pass it a type with a base class, giving us the following
incomplete-but-likely-sufficient implementation of our `Aggregate` concept:

```c++
// @+'base component implementation details'
template<typename T>
concept Aggregate
    =  not std::is_union_v<T>
    && (  std::is_aggregate_v<T>
       || std::is_scalar_v<T>
       )
    ;
// @/

// @+'tests'
static_assert(Aggregate<component_of_parts::parts_t>);
static_assert(Aggregate<my_component_t::inputs_t>);
static_assert(Aggregate<my_component_t::outputs_t>);
// @/
```

## Has Only Components

A pure assembly component is allowed to be represented as a structure
containing only components; essentially an unnamed parts structure. To
recognize this case, we need to be able to tell that all elements of an
aggregate structure are components. We can use `boost::pfr` to extract
a list of members of the structure.

If we take for granted that we have a metafunction that determines whether a
type `T` is a component, we can use `boost::mp11` to very simply check whether
all of the members are components.

```c++
// @+'base component implementation details'
template<typename T> using is_component = std::true_type;

using boost::mp11::mp_apply;
using boost::mp11::mp_all;
using boost::mp11::mp_transform;
template<Aggregate T> struct aggregate_reflection
{
    static constexpr T t{};
    static constexpr auto tup = boost::pfr::structure_to_tuple(t);
    using members = decltype(tup);

    using has_only_components =
        mp_apply< mp_all
                , mp_transform< is_component
                              , members
                              >
                >;
};
// @/
```

The tricky part then is defining `is_component`, since this metafunction is
necessarily recursive. Whether something is a component may depend on whether
it contains only components, which depends on whether its members are
components, which may depend on whether they contain only components... and so
on. By putting all our reflection into a struct, we can break the recursion
using SFINAE to branch to a base case for components that aren't aggregates of
components.

```c++
// @+'base component implementation details'

template<typename T>
concept has_only_components = true;
// @/
```

# Clearable Flags

Many components have endpoints with message semantics, e.g. by its value having
semantics similar to a pointer or `std::optional`. These values are expected to
be cleared so that they have a `false` interpretation unless the value has been
set just before or during the current call to the component's main subroutine.
To facilitate bindings implementing this behavior in a consistent way, the
following subroutine is implemented, that reflects over a component's endpoints
and clears all of its endpoints with this semantics.

A test is not provided for this function here, since its use in the CLI binding
is well tested.

```c++
// @#'components.hpp'
#pragma once

#include <boost/pfr.hpp>
#include <boost/mp11.hpp>
#include "concepts/metadata.hpp"
#include "concepts/functions.hpp"
#include "concepts/endpoints.hpp"

namespace sygaldry { namespace concepts {

@{base component concepts}

template<typename T>
void clear_flags(T& entities)
{
    if constexpr (Component<T>)
    {
        clear_flags(inputs_of(entities));
        clear_flags(outputs_of(entities));
    }
    else
    {
        boost::pfr::for_each_field(entities, []<typename Y>(Y& endpoint)
        {
            if constexpr (ClearableFlag<Y>) clear_flag(endpoint);
        });
    }
}

template<Component T>
void activate(T& component)
{
    clear_flags(outputs_of(component));
    if constexpr (requires {component.main(component.inputs, component.outputs);})
        component.main(component.inputs, component.outputs);
    else if constexpr (requires {component(component.inputs, component.outputs);})
        component(component.inputs, component.outputs);
    else if constexpr (requires {component();})
        component();
    clear_flags(inputs_of(component));
}

} }
// @/
```

```c++
// @#'tests/components/tests.cpp'
#include <type_traits>
#include <map>
#include <catch2/catch_test_macros.hpp>
#include "helpers/metadata.hpp"
#include "concepts/components.hpp"

using namespace sygaldry::concepts;
using namespace sygaldry::helpers;

@{tests}
// @/
```

```cmake
# @#'tests/components/CMakeLists.txt'
add_executable(components-concepts-tests tests.cpp)
target_link_libraries(components-concepts-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(components-concepts-tests)
# @/
```
