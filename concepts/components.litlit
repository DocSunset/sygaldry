# Components Concepts

We consider two kinds of components: regular components and pure assemblies.

```c++
// @='Component'
template<typename T>
concept Component = RegularComponent<T> || PureAssembly<T>;
// @/
```

A regular component has a name, a main subroutine, and at least one of
endpoints, throughpoints, parts, or plugins.

```c++
// @='RegularComponent'
template<typename T>
concept RegularComponent = has_main_subroutine<T> && has_name<T> &&
        ( has_inputs<T> || has_outputs<T> || has_parts<T>
        // TODO || has_throughpoints<T> || has_plugins<T>
        );
// @/

// @+'tests'
struct my_component_t : name_<"component concept test component">
{
    struct inputs_t {} inputs;
    struct outputs_t {} outputs;
    struct parts_t {} parts;
    static void main(const inputs_t&, outputs_t&) {}
} my_component;

static_assert(has_main_subroutine<my_component_t>);
static_assert(has_inputs<my_component_t>);
static_assert(has_outputs<my_component_t>);
static_assert(has_parts<my_component_t>);
static_assert(RegularComponent<my_component_t>);
static_assert(Component<my_component_t>);
// @/
```

A pure assembly has only parts, no inputs or outputs, and no main subroutine,
and it is not required to have a name. A pure assembly may also be represented
by a simple aggregate struct of components.

```c++
// @='PureAssembly'
template<typename T>
concept PureAssembly = (is_simple_aggregate<T> && has_only_components<T>) ||
    ( has_parts<T> && not ( has_main_subroutine<T>
    || has_inputs<T> || has_outputs<T>
    // TODO || has_throughpoints<T> || has_plugins<T>
    ) );
// @/

// @+'tests'
struct struct_of_components
{
    my_component_t component;
} my_assembly1;

struct component_of_parts : name_<"component concept test assembly">
{
    struct parts_t {
        my_component_t component;
    } parts;
} my_assembly2;

static_assert(is_simple_aggregate<struct_of_components>);
static_assert(has_only_components<struct_of_components>);
static_assert(PureAssembly<struct_of_components>);
//static_assert(Component<struct_of_components>);

static_assert(has_parts<component_of_parts>);
static_assert(not has_main_subroutine<component_of_parts>);
static_assert(not has_inputs<component_of_parts>);
static_assert(not has_outputs<component_of_parts>);
static_assert(PureAssembly<component_of_parts>);
//static_assert(Component<component_of_parts>);
// @/
```

```c++
// @='base component concepts'
@{base component implementation details}

@{RegularComponent}

@{PureAssembly}

//@{Component}
template<typename T>
concept Component = requires (T t) {t.inputs; t.outputs;};
// @/
```

## Component Concepts Implementation

To detect whether a component has parts, inputs, or outputs, we employ the same
structure parameterized on the expected name of the nested simple aggregate
structure. We use a macro to avoid repetition. A similar pattern is used
[to define `has_name`](concepts/metadata.litlit).

```c++
// @+'base component implementation details'
#define has_type_or_value(NAME)\
template<typename T> concept has_##NAME##_member = requires (T t) { t.NAME; };\
template<typename T> concept has_##NAME##_type = requires { typename T::NAME; };\
template<typename T> concept has_##NAME##_t = requires { typename T::NAME##_t; };\
template<typename T>\
concept has_##NAME \
    =  has_##NAME##_member<T>\
    || has_##NAME##_type<T>\
    || has_##NAME##_t<T>;\
\
template<typename T> requires has_##NAME##_member<T> auto& NAME##_of(T& t) { return t.NAME; }\
template<typename T> requires has_##NAME##_member<T> const auto& NAME##_of(const T& t) { return t.NAME; }

has_type_or_value(inputs);
has_type_or_value(outputs);
has_type_or_value(parts);

#undef has_type_or_value
// @/

// @+'tests'
static_assert(std::same_as<my_component_t::inputs_t&, decltype(inputs_of(my_component))>);
static_assert(std::same_as<my_component_t::outputs_t&, decltype(outputs_of(my_component))>);
static_assert(std::same_as<my_component_t::parts_t&, decltype(parts_of(my_component))>);
// @/
```

Using our small [function reflection library](concepts/functions.litlit) we can
tell whether a component has a main subroutine by checking whether the return
type of the expected methods (`T::main` or `T::operator()`) have the expected
type (void). This concept will not be satisfied if `T::main` is a variable,
since function reflection is impossible in this case and checking the return
type is thus an error.

```c++
// @+'base component implementation details'
template<typename T>
concept has_main_subroutine
    =  std::same_as<void, typename function_reflection<&T::operator()>::return_type>
    || std::same_as<void, typename function_reflection<&T::main>::return_type>
    ;
// @/

// @+'tests'
struct void_main { void main() {} };
struct void_operator { void operator()() {} };
static_assert(has_main_subroutine<void_main>);
static_assert(has_main_subroutine<void_operator>);

struct member_main { int main; };
struct int_main { int main() {return 1;} };
struct int_operator { int operator()() {return 1;} };
static_assert(!has_main_subroutine<member_main>);
static_assert(!has_main_subroutine<int_main>);
static_assert(!has_main_subroutine<int_operator>);
// @/
```

## Simple Aggregate

TODO

```c++
// @+'base component implementation details'
template<typename T>
concept is_simple_aggregate = true;
// @/
```

## Has Only Components

TODO

```c++
// @+'base component implementation details'
template<typename T>
concept has_only_components = true;
// @/
```

# Clearable Flags

Many components have endpoints with message semantics, e.g. by its value having
semantics similar to a pointer or `std::optional`. These values are expected to
be cleared so that they have a `false` interpretation unless the value has been
set just before or during the current call to the component's main subroutine.
To facilitate bindings implementing this behavior in a consistent way, the
following subroutine is implemented, that reflects over a component's endpoints
and clears all of its endpoints with this semantics.

A test is not provided for this function here, since its use in the CLI binding
is well tested.

```c++
// @#'components.hpp'
#pragma once

#include <boost/pfr.hpp>
#include "concepts/metadata.hpp"
#include "concepts/functions.hpp"
#include "concepts/endpoints.hpp"

namespace sygaldry { namespace concepts {

@{base component concepts}

template<typename T>
void clear_flags(T& entities)
{
    if constexpr (Component<T>)
    {
        clear_flags(inputs_of(entities));
        clear_flags(outputs_of(entities));
    }
    else
    {
        boost::pfr::for_each_field(entities, []<typename Y>(Y& endpoint)
        {
            if constexpr (ClearableFlag<Y>) clear_flag(endpoint);
        });
    }
}

template<Component T>
void activate(T& component)
{
    clear_flags(outputs_of(component));
    if constexpr (requires {component.main(component.inputs, component.outputs);})
        component.main(component.inputs, component.outputs);
    else if constexpr (requires {component(component.inputs, component.outputs);})
        component(component.inputs, component.outputs);
    else if constexpr (requires {component();})
        component();
    clear_flags(inputs_of(component));
}

} }
// @/
```

```c++
// @#'tests/components/tests.cpp'
#include <type_traits>
#include <catch2/catch_test_macros.hpp>
#include "helpers/metadata.hpp"
#include "concepts/components.hpp"

using namespace sygaldry::concepts;
using namespace sygaldry::helpers;

@{tests}
// @/
```

```cmake
# @#'tests/components/CMakeLists.txt'
add_executable(components-concepts-tests tests.cpp)
target_link_libraries(components-concepts-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(components-concepts-tests)
# @/
```
