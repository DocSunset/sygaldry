# Components Concepts

We consider two kinds of components: regular components, and container
components.

A regular component has a name, a main subroutine, and at least one of
endpoints, throughpoints, parts, or plugins. If it has inputs, outputs, or
parts, these must be simple aggregate containers. They are expected to contain
endpoints (inputs and outputs) or subcomponents (parts), but they are not
required to.

```c++
// @='Component'
template<typename T>
concept Component = has_main_subroutine<T> && has_name<T> &&
        ( has_inputs<T> || has_outputs<T> || has_parts<T>
        // TODO || has_throughpoints<T> || has_plugins<T>
        );
// @/

// @+'tests'
struct regular_component_t : name_<"regular component">
{
    struct inputs_t {} inputs;
    struct outputs_t {} outputs;
    struct parts_t {} parts;
    static void main(const inputs_t&, outputs_t&) {}
} regular_component;

static_assert(has_main_subroutine<regular_component_t>);
static_assert(has_inputs<regular_component_t>);
static_assert(has_outputs<regular_component_t>);
static_assert(has_parts<regular_component_t>);
static_assert(Component<regular_component_t>);
static_assert(Component<regular_component_t>);
static_assert(not Component<bng<"a bang">>);
// @/
```

A container is merely an aggregate that contains only nested containers and/or
regular components. It may have a name, but it must be declared directly in
the container definition in order to preserve aggregate-ness (e.g. it must not
use the inherited `name_<"name">` helper). Similar to a regular component's
inputs, outputs, and parts structures, a container is expected but not required
to contain components.

```c++
// @='ComponentContainer'
template<typename T>
concept ComponentContainer = SimpleAggregate<T>;
// @/

// @+'tests'
struct container_component_t
{
    static _consteval auto name() {return "container component";}
    regular_component_t component1;
} container_component;

static_assert(SimpleAggregate<container_component_t>);
static_assert(ComponentContainer<container_component_t>);
//static_assert(Component<container_component_t>);
// @/
```

Whereas a regular component's functionality is defined by its main subroutine,
and its subcomponents should not be managed or activated by the runtime
platform bindings and their inputs should not in general be modified
externally, containers are defined in terms of their subcomponents, which
should be treated as regular components by the runtime platform bindings,
activated accordingly, and exposed for external control inputs.

```c++
// @='base component concepts'
@{base component implementation details}

@{Component}

@{ComponentContainer}
// @/
```

## ComponentContainer

A container is a simple aggregate that contains only components. We begin here,
since the definition of the `inputs`, `outputs`, and `parts` structures of a
regular component depends on the definition of a simple aggregate aggregate
developed here.

### Simple Aggregate

Our notion of a simple aggregate comes from `boost::pfr`, which we rely on for
the ability to iterate over lists of endpoints and components in the form of
structures, an essential functionality for our purposes. We would ideally defer
to `boost::pfr` for our test of simple aggregate requirements, but a straightforward
concept--

```c++
template<typename T>
concept SimpleAggregate = requires { boost::pfr::tuple_size_v<T>; };

```

--does not provide the required results. It appears as though the compiler
considers this to be a valid expression regardless of the result, even if pfr
itself would raise several static assertion failures with the given `T`.

Attempts to defer to `std::is_aggregate_v<T>` in a similar fashion were also
unsatisfactory, with various test structures passing the test even through
`boost::pfr` rejects them at compile time through static assertions. It doesn't
help that `boost::pfr`'s implementation and documentation don't always agree on
what the requirements are:

```c++
// @+'tests'
// docs say: aggregates may not have base classes
struct not_simple_aggregate1 : name_<"foo"> { };
static_assert(std::is_aggregate_v<not_simple_aggregate1>); // passes
// auto failure = boost::pfr::tuple_size_v<not_simple_aggregate1>; // static assertion failure

// docs say: aggregates may not have const fields
struct not_simple_aggregate2 { const int i; };
static_assert(std::is_aggregate_v<not_simple_aggregate2>); // passes
static_assert(1 == boost::pfr::tuple_size_v<not_simple_aggregate2>); // works fine, even though the docs say it's not allowed

// docs say: aggregates may not have reference fields
struct not_simple_aggregate3 { int& i; };
static_assert(std::is_aggregate_v<not_simple_aggregate3>); // passes
static_assert(1 == boost::pfr::tuple_size_v<not_simple_aggregate3>); // works fine, even though the docs say it's not allowed

// docs say: aggregates may not have c arrays
struct not_simple_aggregate4 { float f; int i[5]; };
static_assert(std::is_aggregate_v<not_simple_aggregate4>); // passes
static_assert(6 == boost::pfr::tuple_size_v<not_simple_aggregate4>); // works fine, even though the docs say it's not allowed, although arguably this should return 2?

// docs say: aggregates may not have constructors
struct not_simple_aggregate5 { float f; not_simple_aggregate5(float a, float b) : f{a + b} {} };
static_assert(not std::is_aggregate_v<not_simple_aggregate5>); // a class with a constructor is not aggregate
//auto failure = boost::pfr::tuple_size_v<not_simple_aggregate5>; // static assertion failure

// docs don't mention scalars, but implementation suggests they're fine
using not_simple_aggregate6 = float;
static_assert(not std::is_aggregate_v<not_simple_aggregate6>); // a float is not aggregate
static_assert(std::is_scalar_v<not_simple_aggregate6>); // a float is scalar
static_assert(1 == boost::pfr::tuple_size_v<not_simple_aggregate6>); // works, in accordance with the docs

// docs say: unions not allowed
union not_simple_aggregate7 {float f; int i;} nope;
static_assert(std::is_aggregate_v<not_simple_aggregate7>); // passes
// auto failure = boost::pfr::structure_to_tuple(nope); // static assertion failure
// @/
```

In most cases, `boost::pfr` seems to work when `std::is_aggregate_v` is true,
and to fail when it is not. The only exceptions we noted in our tests are when
`T` is scalar, such as a single `float`, when `T` is a union, and when `T` has
any base class. We can easily detect when `T` is scalar or union using
`std::is_scalar` and `std::is_union` respectively. However, it is challenging
to detect when `T` has a base class. For now, we defer this issue to
`boost::pfr`, which will in any case raise a static assertion failure if we try
to pass it a type with a base class, giving us the following
incomplete-but-likely-sufficient implementation of our `SimpleAggregate` concept:

```c++
// @+'base component implementation details'
template<typename T>
concept SimpleAggregate
    =  not std::is_union_v<T>
    && (  std::is_aggregate_v<T>
       || std::is_scalar_v<T>
       )
    ;
// @/

// @+'tests'
static_assert(SimpleAggregate<regular_component_t::inputs_t>);
static_assert(SimpleAggregate<regular_component_t::outputs_t>);
static_assert(SimpleAggregate<regular_component_t::parts_t>);
static_assert(SimpleAggregate<container_component_t>);
// @/
```

## Regular Component

A regular component has a name, a main subroutine, and at least one of
endpoints, throughpoints, parts, or plugins.

### Parts, Inputs, Outputs

To detect whether a component has parts, inputs, or outputs, we employ the same
structure parameterized on the expected name of the nested simple aggregate
structure. We use a macro to avoid repetition. A similar pattern is used
[to define `has_name`](concepts/metadata.litlit).

```c++
// @+'base component implementation details'
#define has_type_or_value(NAME)\
template<typename T> concept has_##NAME##_member = requires (T t) { t.NAME; requires SimpleAggregate<decltype(t.NAME)>; };\
template<typename T> concept has_##NAME##_type = requires { typename T::NAME; requires SimpleAggregate<typename T::NAME>; };\
template<typename T> concept has_##NAME##_t = requires { typename T::NAME##_t; requires SimpleAggregate<typename T::NAME##_t>; };\
template<typename T>\
concept has_##NAME \
    =  has_##NAME##_member<T>\
    || has_##NAME##_type<T>\
    || has_##NAME##_t<T>;\
\
template<typename T> requires has_##NAME##_member<T> auto& NAME##_of(T& t) { return t.NAME; }\
template<typename T> requires has_##NAME##_member<T> const auto& NAME##_of(const T& t) { return t.NAME; }

has_type_or_value(inputs);
has_type_or_value(outputs);
has_type_or_value(parts);

#undef has_type_or_value
// @/

// @+'tests'
static_assert(std::same_as<regular_component_t::inputs_t&, decltype(inputs_of(regular_component))>);
static_assert(std::same_as<regular_component_t::outputs_t&, decltype(outputs_of(regular_component))>);
static_assert(std::same_as<regular_component_t::parts_t&, decltype(parts_of(regular_component))>);
// @/
```

### Main Subroutine

Using our small [function reflection library](concepts/functions.litlit) we can
tell whether a component has a main subroutine by checking whether the return
type of the expected methods (`T::main` or `T::operator()`) have the expected
type (void). This concept will not be satisfied if `T::main` is a variable,
since function reflection is impossible in this case and checking the return
type is thus an error.

```c++
// @+'base component implementation details'
template<typename T>
concept has_main_subroutine
    =  std::same_as<void, typename function_reflection<&T::operator()>::return_type>
    || std::same_as<void, typename function_reflection<&T::main>::return_type>
    ;
// @/

// @+'tests'
struct void_main { void main() {} };
struct void_operator { void operator()() {} };
static_assert(has_main_subroutine<void_main>);
static_assert(has_main_subroutine<void_operator>);

struct member_main { int main; };
struct int_main { int main() {return 1;} };
struct int_operator { int operator()() {return 1;} };
static_assert(not has_main_subroutine<member_main>);
static_assert(not has_main_subroutine<int_main>);
static_assert(not has_main_subroutine<int_operator>);
// @/
```

# Accessing Subcomponents and Endpoints

Given a list of components, such as a parts struct or container component,
there are several common operations that are required: apply a generic function
(especially a lambda) to every component in the list, every endpoint of every
component in the list, every input or output only, or to every node in the
component-endpoint tree; find a certain component or components in the list,
find a certain aggregate of endpoints or components in the list, and find a
certain endpoint or endpoints in the list.

```c++
// @+'tests'
struct dummy_component {
    struct inputs_t {
        struct ep1_t : name_<"ep1">, persistent<float> {} ep1;
    } inputs;

    struct outputs_t {
        struct ep2_t : name_<"ep2">, persistent<float> {} ep2;
    } outputs;

    struct parts_t {
        struct dummy_part : name_<"dp"> {
            struct parts_t {
                static _consteval auto name() {return "dpp";}
            } parts;
            void main() {};
        } part;
    } parts;

    void main() {}
};

struct accessor_test_container_t
{
    static _consteval auto name() {return "container";}
    struct c1_t : dummy_component, name_<"c1"> {} c1;
    struct c2_t : dummy_component, name_<"c2"> {} c2;
} accessor_test_container;

static_assert(Component<accessor_test_container_t::c1_t>);
static_assert(Component<accessor_test_container_t::c2_t>);
static_assert(Component<dummy_component::parts_t::dummy_part>);
static_assert(ComponentContainer<accessor_test_container_t>);

TEST_CASE("for each X")
{
    string allnames{};
    auto add_names = [&](auto& entity)
    {
        allnames += string(entity.name());
    };

    SECTION("for each component")
    {
        for_each_component(accessor_test_container, add_names);
        REQUIRE(allnames == string("c1dpc2dp"));
    }

    SECTION("for each endpoint")
    {
        for_each_endpoint(accessor_test_container, add_names);
        REQUIRE(allnames == string("ep1ep2ep1ep2"));
    }

    SECTION("for each input")
    {
        for_each_input(accessor_test_container, add_names);
        REQUIRE(allnames == string("ep1ep1"));
    }

    SECTION("for each output")
    {
        for_each_output(accessor_test_container, add_names);
        REQUIRE(allnames == string("ep2ep2"));
    }

    SECTION("for each node")
    {
        string allnodes{};
        auto add_node = [&]<typename T>(T& entity, auto tag)
        {
            if constexpr (has_name<T>) allnodes += string(entity.name());
        };
        for_each_node(accessor_test_container, add_node);
        REQUIRE(allnodes == string("containerc1ep1ep2dpdppc2ep1ep2dpdpp"));
    }
}
// @/
```

## For each

Most of these are reasonably straightforward and presented without comment.

```c++
// @='for each'
template<typename T>
    requires Component<T> || ComponentContainer<T>
constexpr auto for_each_component(T& component, auto callback)
{
    if constexpr (Component<T>)
    {
        callback(component);
        if constexpr (has_parts<T>)
            for_each_component(parts_of(component), callback);
    } else /* ComponentContainer */
    {
        boost::pfr::for_each_field(component, [&]<typename Y>(Y& subcomponent) {
            if constexpr (Component<Y> || ComponentContainer<Y>)
                for_each_component(subcomponent, callback);
        });
    }
}

template<typename T>
    requires Component<T> || ComponentContainer<T>
constexpr auto for_each_endpoint(T& component, auto callback)
{
    for_each_component(component, [&]<typename Y>(Y& subcomponent)
    {
        if constexpr (has_inputs<Y>)
            boost::pfr::for_each_field(inputs_of(subcomponent), callback);
        if constexpr (has_outputs<Y>)
            boost::pfr::for_each_field(outputs_of(subcomponent), callback);
    });
}

template<typename T>
    requires Component<T> || ComponentContainer<T>
constexpr auto for_each_input(T& component, auto callback)
{
    for_each_component(component, [&]<typename Y>(Y& subcomponent)
    {
        if constexpr (has_inputs<Y>)
            boost::pfr::for_each_field(inputs_of(subcomponent), callback);
    });
}

template<typename T>
    requires Component<T> || ComponentContainer<T>
constexpr auto for_each_output(T& component, auto callback)
{
    for_each_component(component, [&]<typename Y>(Y& subcomponent)
    {
        if constexpr (has_outputs<Y>)
            boost::pfr::for_each_field(outputs_of(subcomponent), callback);
    });
}
// @/
```

`for_each_node` requires some further exposition. The structure is very similar
to the above, except in addition to calling the callback for components and
endpoints, `for_each_node` also calls back for the aggregates encountered along
the way. To help the user distinguish between a component container, component,
input or output endpoint aggregate, parts aggregate, or endpoint, an empty tag
class is passed as the second argument to the callback. Some helpers are
provided to facilitate compile-time branching depending on the type of node.

```c++
// @+'for each'
namespace node
{
    struct component_container {};
    struct component {};
    struct inputs_container {};
    struct outputs_container {};
    struct parts_container {};
    struct input_endpoint {};
    struct output_endpoint {};
    template<typename> constexpr bool is_component_container = false;
    template<> constexpr bool is_component_container<component_container> = true;
    template<typename> constexpr bool is_component = false;
    template<> constexpr bool is_component<component> = true;
    template<typename> constexpr bool is_inputs_container = false;
    template<> constexpr bool is_inputs_container<inputs_container> = true;
    template<typename> constexpr bool is_outputs_container = false;
    template<> constexpr bool is_outputs_container<outputs_container> = true;
    template<typename> constexpr bool is_parts_container = false;
    template<> constexpr bool is_parts_container<parts_container> = true;
    template<typename> constexpr bool is_input_endpoint = false;
    template<> constexpr bool is_input_endpoint<input_endpoint> = true;
    template<typename> constexpr bool is_output_endpoint = false;
    template<> constexpr bool is_output_endpoint<output_endpoint> = true;
    template<typename> constexpr bool is_endpoints_container = false;
    template<> constexpr bool is_endpoints_container<inputs_container> = true;
    template<> constexpr bool is_endpoints_container<outputs_container> = true;
    template<typename> constexpr bool is_endpoint = false;
    template<> constexpr bool is_endpoint<input_endpoint> = true;
    template<> constexpr bool is_endpoint<output_endpoint> = true;
}

template<typename T>
constexpr auto for_each_node(T& component, auto callback)
{
    if constexpr (Component<T>)
    {
        callback(component, node::component{});
        if constexpr (has_inputs<T>)
        {
            auto& inputs = inputs_of(component);
            callback(inputs, node::inputs_container{});
            boost::pfr::for_each_field(inputs, [&](auto& in)
            {
                callback(in, node::input_endpoint{});
            });
        }
        if constexpr (has_outputs<T>)
        {
            auto& outputs = outputs_of(component);
            callback(outputs, node::outputs_container{});
            boost::pfr::for_each_field(outputs, [&](auto& out)
            {
                callback(out, node::output_endpoint{});
            });
        }
        if constexpr (has_parts<T>)
        {
            auto& parts = parts_of(component);
            callback(parts, node::parts_container{});
            boost::pfr::for_each_field(parts, [&](auto& part)
            {
                for_each_node(part, callback);
            });
        }
    } else if constexpr (ComponentContainer<T>)
    {
        callback(component, node::component_container{});
        boost::pfr::for_each_field(component, [&](auto& subcomponent)
        {
            for_each_node(subcomponent, callback);
        });
    } else return; // this should never happen
}
// @/
```

# Clearable Flags

Many components have endpoints with message semantics, e.g. by its value having
semantics similar to a pointer or `std::optional`. These values are expected to
be cleared so that they have a `false` interpretation unless the value has been
set just before or during the current call to the component's main subroutine.
To facilitate bindings implementing this behavior in a consistent way, the
following subroutine is implemented, that reflects over a component's endpoints
and clears all of its endpoints with this semantics.

A test is not provided for this function here, since its use in the CLI binding
is well tested.

```c++
// @='clear_flags'
template<typename T>
void clear_flags(T& entities)
{
    if constexpr (Component<T>)
    {
        clear_flags(inputs_of(entities));
        clear_flags(outputs_of(entities));
    }
    else
    {
        boost::pfr::for_each_field(entities, []<typename Y>(Y& endpoint)
        {
            if constexpr (ClearableFlag<Y>) clear_flag(endpoint);
        });
    }
}
// @/
```

# Activate

```c++
// @='activate'
template<Component T>
void activate(T& component)
{
    clear_flags(outputs_of(component));
    if constexpr (requires {component.main(component.inputs, component.outputs);})
        component.main(component.inputs, component.outputs);
    else if constexpr (requires {component(component.inputs, component.outputs);})
        component(component.inputs, component.outputs);
    else if constexpr (requires {component();})
        component();
    clear_flags(inputs_of(component));
}
// @/
```

# Summary

```c++
// @#'components.hpp'
#pragma once

#include <boost/pfr.hpp>
#include <boost/mp11.hpp>
#include "concepts/metadata.hpp"
#include "concepts/functions.hpp"
#include "concepts/endpoints.hpp"

namespace sygaldry { namespace concepts {

@{base component concepts}

@{for each}

@{clear_flags}

@{activate}

} }
// @/
```

```c++
// @#'tests/components/tests.cpp'
#include <type_traits>
#include <string>
#include <catch2/catch_test_macros.hpp>
#include "helpers/metadata.hpp"
#include "helpers/endpoints.hpp"
#include "concepts/components.hpp"

using namespace sygaldry::concepts;
using namespace sygaldry::helpers;
using std::string;

@{tests}
// @/
```

```cmake
# @#'tests/components/CMakeLists.txt'
add_executable(components-concepts-tests tests.cpp)
target_link_libraries(components-concepts-tests PRIVATE Catch2::Catch2WithMain)
catch_discover_tests(components-concepts-tests)
# @/
```
