# The Build System

# CMake

CMake is currently used as the default project build system, currently mainly
employed to build test code. However, certain hardware platforms require (or
heavily incentivise) use of particular build systems; these are used where
appropriate.

# Literate Sources

Literate programming is employed throughout the project. The literate sources
are considered authoritative, and are used to generate most other source files,
including CMakeLists.txt files. The following line of shell script can
regenerate all machine sources from the litlit literate source files.
For each `.litlit` file found in the repository with `find`, the script
finds the first file generated by that literate source, and if the source
is more recently modified than the generated file, reruns `litlit` to
regenerate all files derived from that literate source. GNU `parallel` is
used to perform this subroutine for all literate sources.
Run this script from the root of the repository:

```sh
# @#'sh/litlit.sh'
# generate machine sources from literate source code
find -iname '*.litlit' | parallel '
    cd {//}
    generated="$(grep -m 1 -h -r -I "@@#" {/} | head -n 1 | sed 's/^.*@#.//' | sed 's/.$//')"
    [ "$generated" ] && [ {/} -nt "$generated" ] &&
    {
        echo {} "newer than $generated, running litlit..."
        litlit {/}
    }
'
find -iname '*.litlit' | parallel '
    cd {//}
    [ -L "README.md" ] &&
    {
        [ "$(readlink README.md)" != {/} ] && rm "README.md" && ln -s -T {/} README.md
    } || [ ! -e "README.md" ] &&
        ln -s -T {/} README.md
'
# @/
```

Where there is code to compile, or anything remotely interesting,
CMakeLists.txt files are generated from literate source code in the same
directory. When the CMakeLists.txt is trivially simple (e.g. simply including
subdirectories), it is hardcoded without comment.

# Building

A simple shell script is provided to run the compiler and test suite, useful
for development. Run it from the root of the project passing the name of the
build directory as first argument.

```sh
# @#'sh/run.sh'
./sh/litlit.sh
[ "$#" -gt 0 ] && dir="$1" || dir='_build_debug'
[ -d "$dir" ] || CMAKE_BUILD_TYPE=Debug cmake -B "$dir" -S .
cmake --build "$dir" &&
{
    ctest --test-dir "$dir" ||
        ctest --test-dir "$dir" --rerun-failed --output-on-failure
}
# @/
```

# Testing Framework

Catch2 is used for unit testing on platforms where it can run. Other platforms
may use a different testing methodology.

```cmake
# @='Fetch Catch2'
Include(FetchContent)

FetchContent_Declare(
  Catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG        v3.3.2 # or a later release
)

FetchContent_MakeAvailable(Catch2)
# @/

# @='Include automatic test registration'
list(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras)
include(CTest)
include(Catch)
# @/
```

See [the Catch2 CMake integration documentation](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#top) for more detail.

# Language Standard

We require C++20 without extensions.

```cmake
# @='Set language standard'
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED On)
set(CMAKE_CXX_EXTENSIONS Off)
# @/
```

# Libraries

```cmake
# @='Include libraries'
include_directories(dependencies/pfr/include)
include_directories(dependencies/mp11/include)
include_directories(./)
set(AVENDISH_INCLUDE_SOURCE_ONLY ON)
include_directories(dependencies/avendish/include/)
# @/
```

# Platform Specific

## ESP32

ESP32 projects are added as external CMake projects, passing in the root
directory for `sygaldry` so that the IDF build system can be directed toward
the library and its ESP-IDF components.

It appears that adding the ESP32 projects as external projects is the simplest
approach. I conducted some cursory experiments trying to use the ESP-IDF cmake
library functions, e.g. `idf_build_process`, but it appears as though it is not
their intended usage for a firmware project to be included as a subproject. The
toolchain configured by the parent cmake appears to be incompatible with the
IDF project, and the IDF cmake library functions don't appear to make any
attempt to override the selected toolchain in a way that makes things work out.

```c++
# @='add_esp32_project function'
    function(add_esp32_project)
    if (${ARGC} LESS 1)
        message(FATAL_ERROR "add_esp32_project requires a project directory")
    endif()

    set(esp32_project_name ${ARGV0})

    if (NOT IS_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/${esp32_project_name})
        message(FATAL_ERROR "add_esp32_project: argument ${CMAKE_CURRENT_LIST_DIR}/${esp32_project_name} is not a valid directory")
    endif()

    if (ESP_PLATFORM)
        return() # avoid recursively building ESP-IDF projects as external projects of themselves
    endif()

    message(STATUS ${esp32_project_name} "ESP32 project added")

    include(ExternalProject)

    ExternalProject_Add(${esp32_project_name}
            PREFIX ${esp32_project_name}
            BUILD_ALWAYS ON
            INSTALL_COMMAND ${SYGALDRY_ROOT}/sh/esp32-install.sh ${esp32_project_name} make flash # TODO: determine generator
            SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/${esp32_project_name}
            CMAKE_CACHE_ARGS -DSYGALDRY_ROOT:STRING=${SYGALDRY_ROOT})
endfunction()
# @/
```

The default install phase for such projects will fail for these projects, or
worse, if granted super user priviledges, will install a bunch or random
nonsense to the user's system.

A simple script is provided as an alternative installer. It looks for `ESPPORT`
defined in the environment and tries to flash the firmware using the given
serial device port.

```sh
# @#'sh/esp32-install.sh'
echo $0
[ "$1" = "$ESPPROJ" ] || { echo "Skipping this build ($1) which doesn't match ESPPROJ ($ESPPROJ)" ; exit ; }
shift 1
[ -c "$ESPPORT" -a -w "$ESPPORT" ] && $@@ || echo "No valid ESPPORT ($ESPPORT), skipping install"
echo "flashed successfully"
# @/
```

# Summary

```cmake
# @#'CMakeLists.txt'
cmake_minimum_required(VERSION 3.26)
project(Sygaldry)
set(SYGALDRY_ROOT ${CMAKE_CURRENT_LIST_DIR})

@{Set language standard}

@{add_esp32_project function}

@{Fetch Catch2}

@{Include automatic test registration}

@{Include libraries}

add_subdirectory(utilities)
add_subdirectory(concepts)
add_subdirectory(helpers)
add_subdirectory(components)
add_subdirectory(bindings)
add_subdirectory(instruments)
add_subdirectory(tests)
# @/
```
