\page build_system The Build System

Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music
Interaction Laboratory (IDMIL), Centre for Interdisciplinary Research in Music
Media and Technology (CIRMMT), McGill University, Montréal, Canada, and Univ.
Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

SPDX-License-Identifier: MIT

[TOC]

# CMake

CMake is currently used as the default project build system, currently mainly
employed to build test code. However, certain hardware platforms require (or
heavily incentivise) use of particular build systems; these are used where
appropriate.

# Literate Sources

Literate programming is employed throughout the project. The literate sources
are considered authoritative, and are used to generate most other source files,
including many CMakeLists.txt files. The following shell script can
regenerate all machine sources from the lili literate source files.
For each `.lili.md` file found in the repository with `find`, the script
finds the first file generated by that literate source, and if the source
is more recently modified than the generated file, reruns `lili` to
regenerate all files derived from that literate source. GNU `parallel` is
used to perform this subroutine for all literate sources. The command exits
with a failure code in case any invocation of `lili` fails, which is used
to short-circuit execution of later shell scripts.

Run this script from the root of the repository.

```sh
# @#'sh/lili.sh'
#!/bin/sh -e
# generate machine sources from literate source code

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

find -iname '*.lili.md' | parallel '
    cd {//}
    generated="$(grep -m 1 -h -r -I "@@#" {/} | head -n 1 | sed 's/^.*@#.//' | sed 's/.$//')"
    [ "$generated" ] && [ {/} -nt "$generated" ] &&
    {
        echo {} "newer than $generated, running lili..."
        lili {/} || exit 1 # short circuit on any lili error with failure return code
    } || exit 0
'
# @/
```

Where there is code to compile, or anything remotely interesting,
CMakeLists.txt files are generated from literate source code in the same
directory. When the CMakeLists.txt is trivially simple (e.g. simply including
subdirectories), it is hardcoded without comment.

# Doxygen

In addition to the literate sources, which are intended to document the
implementation and design rationale of the project, public API's are also
documented using Doxygen special comment blocks, and pretty documentation is
generated with Doxygen and Doxygen Awesome CSS. The order in which files are
presented in the generated documentation is controlled by manually specifying
each file to include in the documentation in the project's Doxyfile, in the
configuration variable `INPUT`. Documentation can be generated e.g. by running
`doxygen` in the root of the repository, or using the `run.sh _build_doxygen`
script, which will build both the html and pdf documentation.

# Building

A simple shell script is provided to run the compiler and test suite, or
generate documentation, useful for development. Run it from the root of the
project passing the name of the build directory as first argument. The
directories `_build_debug`, `_build_release`, and `_build_doxygen` are
accounted for and included in `.gitignore`.

```sh
# @#'sh/run.sh'
#!/bin/sh -e

# create the build directory if necessary, then build and test the project

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

./sh/lili.sh || exit 1
[ "$#" -gt 0 ] && dir="$1" || dir='_build_debug'
[ "$dir" = "_build_doxygen" ] && exec sh -c 'doxygen && cd _build_doxygen/latex && make pdf'
[ -d "$dir" ] || {
    [ "$dir" == "_build_release" ] && mode=RelWithDebInfo ||
    [ "$dir" == "_build_debug" ]   && mode=Debug ||
    [ -n "$2" ] && mode="$2" ||
    echo "Using default build mode: Debug" && mode=Debug
    CMAKE_BUILD_TYPE="$mode" cmake -B "$dir" -S .
}
cmake --build "$dir" &&
{
    ctest --test-dir "$dir" ||
        ctest --test-dir "$dir" --rerun-failed --output-on-failure
}
# @/
```

## Building with Clang

Assuming you are building on a machine where `gcc` is the default compiler, you
may wish to compile using `clang` e.g. in order to check for compiler-specific
incompatibilities. You may be able to accomplish this using environment
variables when generating the build directory:

```sh
CC=/usr/bin/clang CXX=/usr/bin/clang++ cmake -D_CMAKE_TOOLCHAIN_PREFIX=llvm -B _build_clang -S .
```

Presumably a similar tactic could be used to compile using `gcc` on a machine where
`clang` is the default, but this hasn't been tested.

# Testing Framework

Catch2 is used for unit testing on platforms where it can run. Other platforms
may use a different testing methodology.

```cmake
# @='Fetch Catch2'
Include(FetchContent)

FetchContent_Declare(
  Catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG        v3.3.2 # or a later release
)

FetchContent_MakeAvailable(Catch2)
# @/

# @='Include automatic test registration'
list(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras)
include(CTest)
include(Catch)
# @/
```

See [the Catch2 CMake integration documentation](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#top) for more detail.

# Language Standard

We require C++20 without extensions.

```cmake
# @='Set language standard'
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED On)
set(CMAKE_CXX_EXTENSIONS Off)
# @/
```

# Libraries

Boost PFR and Boost MP11 are required by the concepts library, and consequently
by any bindings or components that make use of it. RapidJSON is used by the
component of the same name. Several other components make use of specific
libraries, such as liblo and `Trill-Arduino`; these are also included as
submodules, and some may be required to build the default test suite.

```cmake
# @='Include libraries'
# @/
```

# Platform Specific

## ESP32

Building an ESP32 instrument is currently achieved using the normal ESP-IDF
build tools, with the caveat that the argument `-D SYGALDRY_ROOT="..."` must
be passed to `idf.py`, giving the directory in which the root of the Sygaldry
repository is located. For example, the following POSIX shell script, when run from the
root of the repository, would run `idf.py` for the ESP32 instrument located in the
directory passed as the first argument to the script using the command passed
as second argument to the script:

```sh
# @#'sh/idf.sh'
#!/bin/sh -e

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

./sh/lili.sh || exit 1

sygaldry_root="$(pwd)"
cd "$1"
idf.py "$2" -D SYGALDRY_ROOT="$sygaldry_root"
# @/
```

Previously, the CMake `ExternalProject_Add` command was used to incorporate
the ESP32 instruments into the usual build process. However, this resulted
in long compilation times during development, even when the ESP32 targets
were not being tested. The current approach requires more manual intervention
from the developer, but is hoped to save time overall.

At the time of writing, Sygaldry also requires a fairly recent version of the
ESP-IDF; an appropriate version of the framework is included as a submodule,
and should be used when installing and exporting the IDF, before running the
above script or its equivalent on your machine.

ESP-IDF projects should add Sygaldry as a component with the following line:

```cmake
set(EXTRA_COMPONENT_DIRS ${SYGALDRY_ROOT} ${SYGALDRY_ROOT}/components/esp32 ${SYGALDRY_ROOT}/bindings/esp32)
```

# Summary

```cmake
# @#'CMakeLists.txt'
# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

cmake_minimum_required(VERSION 3.26)
if (NOT ESP_PLATFORM)
project(Sygaldry)
set(SYGALDRY_ROOT ${CMAKE_CURRENT_LIST_DIR})

@{Set language standard}

@{Fetch Catch2}

@{Include automatic test registration}

@{Include libraries}

set(SYGALDRY_BUILD_TESTS 1)
endif()

if (ESP_PLATFORM)
idf_component_register()
endif()
add_library(sygaldry INTERFACE)
add_subdirectory(utilities)
add_subdirectory(concepts)
add_subdirectory(helpers)
add_subdirectory(bindings)
add_subdirectory(components)
target_link_libraries(sygaldry INTERFACE Sygaldry::Bindings)
target_link_libraries(sygaldry INTERFACE Sygaldry::Components)
if (ESP_PLATFORM)
target_link_libraries(${COMPONENT_LIB} INTERFACE sygaldry)
endif()
# @/
```
