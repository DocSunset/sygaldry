# The Build System

[TOC]

# CMake

CMake is currently used as the default project build system, currently mainly
employed to build test code. However, certain hardware platforms require (or
heavily incentivise) use of particular build systems; these are used where
appropriate.

# Literate Sources

Literate programming is employed throughout the project. The literate sources
are considered authoritative, and are used to generate most other source files,
including many CMakeLists.txt files. The following shell script can
regenerate all machine sources from the lili literate source files.
For each `.lili.md` file found in the repository with `find`, the script
finds the first file generated by that literate source, and if the source
is more recently modified than the generated file, reruns `lili` to
regenerate all files derived from that literate source. GNU `parallel` is
used to perform this subroutine for all literate sources. The command exits
with a failure code in case any invocation of `lili` fails, which is used
to short-circuit execution of later shell scripts.

Run this script from the root of the repository.

```sh
# @#'sh/lili.sh'
# generate machine sources from literate source code
find -iname '*.lili.md' | parallel '
    cd {//}
    generated="$(grep -m 1 -h -r -I "@@#" {/} | head -n 1 | sed 's/^.*@#.//' | sed 's/.$//')"
    [ "$generated" ] && [ {/} -nt "$generated" ] &&
    {
        echo {} "newer than $generated, running lili..."
        lili {/} || exit 1 # short circuit on any lili error with failure return code
    } || exit 0
'
# @/
```

Where there is code to compile, or anything remotely interesting,
CMakeLists.txt files are generated from literate source code in the same
directory. When the CMakeLists.txt is trivially simple (e.g. simply including
subdirectories), it is hardcoded without comment.

# Doxygen

In addition to the literate sources, which are intended to document the
implementation and design rationale of the project, public API's are also
documented using Doxygen special comment blocks, and pretty documentation is
generated with Doxygen and Doxygen Awesome CSS. The order in which files are
presented in the generated documentation is controlled by manually specifying
each file to include in the documentation in the project's Doxyfile, in the
configuration variable `INPUT`. Documentation can be generated e.g. by running
`doxygen` in the root of the repository, or using the `run.sh _build_doxygen`
script, which will build both the html and pdf documentation.

# Building

A simple shell script is provided to run the compiler and test suite, or
generate documentation, useful for development. Run it from the root of the
project passing the name of the build directory as first argument. The
directories `_build_debug`, `_build_release`, and `_build_doxygen` are
accounted for and included in `.gitignore`.

```sh
# @#'sh/run.sh'
./sh/lili.sh || exit 1
[ "$#" -gt 0 ] && dir="$1" || dir='_build_debug'
[ "$dir" = "_build_doxygen" ] && exec sh -c 'doxygen && cd _build_doxygen/latex && make pdf'
[ -d "$dir" ] || {
    [ "$dir" == "_build_release" ] && mode=RelWithDebInfo ||
    [ "$dir" == "_build_debug" ]   && mode=Debug ||
    [ -n "$2" ] && mode="$2" ||
    echo "Using default build mode: Debug" && mode=Debug
    CMAKE_BUILD_TYPE="$mode" cmake -B "$dir" -S .
}
cmake --build "$dir" &&
{
    ctest --test-dir "$dir" ||
        ctest --test-dir "$dir" --rerun-failed --output-on-failure
}
# @/
```

## Building with Clang

Assuming you are building on a machine where GCC is the default compiler, you
may wish to compile using `clang` e.g. in order to check for compiler-specific
incompatibilities. You may be able to accomplish this using environment
variables when generating the build directory:

```sh
CC=/usr/bin/clang CXX=/usr/bin/clang++ cmake -D_CMAKE_TOOLCHAIN_PREFIX=llvm -B _build_clang -S .
```

# Testing Framework

Catch2 is used for unit testing on platforms where it can run. Other platforms
may use a different testing methodology.

```cmake
# @='Fetch Catch2'
Include(FetchContent)

FetchContent_Declare(
  Catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG        v3.3.2 # or a later release
)

FetchContent_MakeAvailable(Catch2)
# @/

# @='Include automatic test registration'
list(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras)
include(CTest)
include(Catch)
# @/
```

See [the Catch2 CMake integration documentation](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#top) for more detail.

# Language Standard

We require C++20 without extensions.

```cmake
# @='Set language standard'
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED On)
set(CMAKE_CXX_EXTENSIONS Off)
# @/
```

# Libraries

```cmake
# @='Include libraries'
include_directories(dependencies/pfr/include)
include_directories(dependencies/mp11/include)
include_directories(./)
set(AVENDISH_INCLUDE_SOURCE_ONLY ON)
include_directories(dependencies/avendish/include/)
# @/
```

# Platform Specific

## ESP32

ESP32 projects are added as external CMake projects, passing in the root
directory for `sygaldry` so that the IDF build system can be directed toward
the library and its ESP-IDF components.

It appears that adding the ESP32 projects as external projects is the simplest
approach. I conducted some cursory experiments trying to use the ESP-IDF cmake
library functions, e.g. `idf_build_process`, but it appears as though it is not
their intended usage for a firmware project to be included as a subproject. The
toolchain configured by the parent cmake appears to be incompatible with the
IDF project, and the IDF cmake library functions don't appear to make any
attempt to override the selected toolchain in a way that makes things work out.

```cpp
# @='add_esp32_project function'
    function(add_esp32_project)
    if (${ARGC} LESS 1)
        message(FATAL_ERROR "add_esp32_project requires a project directory")
    endif()

    set(esp32_project_name ${ARGV0})

    if (NOT IS_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}/${esp32_project_name})
        message(FATAL_ERROR "add_esp32_project: argument ${CMAKE_CURRENT_LIST_DIR}/${esp32_project_name} is not a valid directory")
    endif()

    if (ESP_PLATFORM)
        return() # avoid recursively building ESP-IDF projects as external projects of themselves
    endif()

    message(STATUS ${esp32_project_name} "ESP32 project added")

    include(ExternalProject)

    ExternalProject_Add(${esp32_project_name}
            PREFIX ${esp32_project_name}
            BUILD_ALWAYS ON
            INSTALL_COMMAND ${SYGALDRY_ROOT}/sh/esp32-install.sh ${esp32_project_name} make flash # TODO: determine generator
            SOURCE_DIR ${CMAKE_CURRENT_LIST_DIR}/${esp32_project_name}
            CMAKE_CACHE_ARGS -DSYGALDRY_ROOT:STRING=${SYGALDRY_ROOT})
endfunction()
# @/
```

The default install phase for such projects will fail for these projects, or
worse, if granted super user priviledges, will install a bunch or random
nonsense to the user's system.

A simple script is provided as an alternative installer. It looks for `ESPPORT`
defined in the environment and tries to flash the firmware using the given
serial device port.

```sh
# @#'sh/esp32-install.sh'
echo $0
[ "$1" = "$ESPPROJ" ] || { echo "Skipping this build ($1) which doesn't match ESPPROJ ($ESPPROJ)" ; exit ; }
shift 1
[ -c "$ESPPORT" -a -w "$ESPPORT" ] && $@@ || echo "No valid ESPPORT ($ESPPORT), skipping install"
echo "flashed successfully"
# @/
```

# Summary

```cmake
# @#'CMakeLists.txt'
cmake_minimum_required(VERSION 3.26)
project(Sygaldry)
set(SYGALDRY_ROOT ${CMAKE_CURRENT_LIST_DIR})

@{Set language standard}

@{add_esp32_project function}

@{Fetch Catch2}

@{Include automatic test registration}

@{Include libraries}

add_subdirectory(utilities)
add_subdirectory(concepts)
add_subdirectory(helpers)
add_subdirectory(components)
add_subdirectory(bindings)
add_subdirectory(instruments)
add_subdirectory(tests)
# @/
```
