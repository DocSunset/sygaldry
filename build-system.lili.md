\page build_system The Build System

Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music
Interaction Laboratory (IDMIL), Centre for Interdisciplinary Research in Music
Media and Technology (CIRMMT), McGill University, Montréal, Canada, and Univ.
Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

SPDX-License-Identifier: MIT

[TOC]

# Build Requirements

A full build requires the following executables:

- lili (the literate programming tool used for the project)
- posix utilities (used in convenience shell scripts)
- gnu parallel (ditto)
- cmake
- doxygen (optional)
- the compiler toolchain for the platform the build targets

If you encounter other prerequisites not described above, please open an issue.

# Convenience Scripts

## Literate Sources

Literate programming is employed throughout the project. The literate sources
are considered authoritative, and are used to generate most other source files,
including many CMakeLists.txt files.

The following shell script can regenerate all machine sources from the lili
literate source files, and it (or something equivalent) should be run before
every build.

For each `.lili.md` file found in the repository with `find`, the script finds
the first file generated by that literate source, and if the source is more
recently modified than the generated file, reruns `lili` to regenerate all
files derived from that literate source. GNU `parallel` is used to perform this
subroutine for all literate sources. The command exits with a failure code in
case any invocation of `lili` fails, which is used to short-circuit execution
of later shell scripts.

Run this script from the root of the repository.

```sh
# @#'sh/lili.sh'
#!/bin/sh -e
# generate machine sources from literate source code

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

find -iname '*.lili.md' | parallel '
    cd {//}
    generated="$(grep -m 1 -h -r -I "@@#" {/} | head -n 1 | sed 's/^.*@#.//' | sed 's/.$//')"
    [ "$generated" ] && [ {/} -nt "$generated" ] &&
    {
        echo {} "newer than $generated, running lili..."
        lili {/} || exit 1 # short circuit on any lili error with failure return code
    } || exit 0
'
# @/
```

### ccache

One limitation of this current approach to literate tangle synchronisation is
that, if any file generated by a given literate source document is changed,
then all files generated by that literate source are regenerated. This poorly
impacts incremental builds, sometimes causing unnecessary recompilation of
machine sources that have not actually changed due to their updated access
times. It is recommended to use [`ccache`](https://ccache.dev/) to work around
this issue, and generally speed up build times.

## Doxygen

In addition to the literate sources, which are intended to document the
implementation and design rationale of the project, public API's are also
documented using Doxygen special comment blocks, and pretty documentation is
generated with Doxygen and Doxygen Awesome CSS. The order in which files are
presented in the generated documentation is controlled by manually specifying
each file as a subpage in [the implementation guide](\ref docs-implementation).
Documentation can be generated e.g. by running `doxygen` in the root of the
repository, or using the `run.sh _build_doxygen` script, which will build both
the html and pdf documentation.

## Building

A simple shell script is provided to run the compiler and test suite, or
generate documentation, useful for development. Run it from the root of the
project passing the name of the build directory as first argument. The
directories `_build_debug`, `_build_release`, and `_build_doxygen` are
accounted for and included in `.gitignore`.

```sh
# @#'sh/run.sh'
#!/bin/sh -e

# create the build directory if necessary, then build and test the project

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

./sh/lili.sh || exit 1
[ "$#" -gt 0 ] && dir="$1" || dir='_build_debug'
[ "$dir" = "_build_doxygen" ] && exec sh -c 'doxygen && cd _build_doxygen/latex && make pdf'
[ -d "$dir" ] || {
    [ "$dir" == "_build_release" ] && mode=RelWithDebInfo ||
    [ "$dir" == "_build_debug" ]   && mode=Debug ||
    [ -n "$2" ] && mode="$2" ||
    echo "Using default build mode: Debug" && mode=Debug
    CMAKE_BUILD_TYPE="$mode" cmake -B "$dir" -S .
}
cmake --build "$dir" &&
{
    ctest --test-dir "$dir" ||
        ctest --test-dir "$dir" --rerun-failed --output-on-failure
}
# @/
```

### Building with Clang

Assuming you are building on a machine where `gcc` is the default compiler, you
may wish to compile using `clang` e.g. in order to check for compiler-specific
incompatibilities. You may be able to accomplish this using environment
variables when generating the build directory:

```sh
CC=/usr/bin/clang CXX=/usr/bin/clang++ cmake -D_CMAKE_TOOLCHAIN_PREFIX=llvm -B _build_clang -S .
```

Presumably a similar tactic could be used to compile using `gcc` on a machine where
`clang` is the default, but this hasn't been tested.

## Platform Specific

### ESP32

Building an ESP32 instrument is currently achieved using the normal ESP-IDF
build tools, with the caveat that the argument `-D SYGALDRY_ROOT="..."` must be
passed to `idf.py`, giving the directory in which the root of the Sygaldry
repository is located. For example, the following POSIX shell script, when run
from the root of the repository, would run `idf.py` for the ESP32 instrument
located in the directory passed as the first argument to the script using the
command passed as second argument to the script. Make sure to source the idf
environment exports first.

```sh
# @#'sh/idf.sh'
#!/bin/sh -e

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

./sh/lili.sh || exit 1

sygaldry_root="$(pwd)"
cd "$1"
idf.py "$2" -D SYGALDRY_ROOT="$sygaldry_root"
# @/
```

Previously, the CMake `ExternalProject_Add` command was used to incorporate
the ESP32 instruments into the usual build process. However, this resulted
in long compilation times during development, even when the ESP32 targets
were not being tested. The current approach requires more manual intervention
from the developer, but is hoped to save time overall.

At the time of writing, Sygaldry also requires a fairly recent version of the
ESP-IDF; an appropriate version of the framework is included as a submodule,
and should be used when installing and exporting the IDF, before running the
above script or its equivalent on your machine.

ESP-IDF projects should add Sygaldry with e.g. the following lines:

```cmake
# idf_component_register( ... ) etc.
add_subdirectory(${SYGALDRY_ROOT} sygbuild)
target_link_libraries(${COMPONENT_LIB} PRIVATE sygaldry)
```

# The CMakeLists.txt

## Sygaldry root

We set a variable allowing components to reach the root of the repository. This
is mainly done so that components can reach the `dependencies` directory
unambiguously as `${SYGALDRY_ROOT}/dependencies`, rather than using a relative
path that might break if the component is physically moved.

```cmake
# @='set SYGALDRY_ROOT'
set(SYGALDRY_ROOT ${CMAKE_CURRENT_LIST_DIR})
# @/
```

## Language Standard

We require C++20 without extensions.

```cmake
# @='set language standard'
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED On)
set(CMAKE_CXX_EXTENSIONS Off)
# @/
```

Each of the project's main package groups is declared as a cmake interface
library. The top level package group then links to each of the package
interface libraries so that clients can link to the whole project if that
is convenient. The list file is structured so that the components included
in a given package group are added with `add_subdirectory` in an indented
block that begins when the library is declared, and ends when it is linked
into its parent package group.

## Testing Framework

Catch2 is used for unit testing on platforms where it can run. Other platforms
may use a different testing methodology.

```cmake
# @='Fetch Catch2'
Include(FetchContent)

FetchContent_Declare(
  Catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG        v3.3.2 # or a later release
)

FetchContent_MakeAvailable(Catch2)
# @/

# @='Include automatic test registration'
list(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras)
include(CTest)
include(Catch)
# @/
```

Catch2 is not a good testing framework for ESP32, so the code to enable it
is disabled for that platform.

```cmake
# @='prepare for tests'
if (NOT ESP_PLATFORM)
@{Fetch Catch2}
@{Include automatic test registration}
set(SYGALDRY_BUILD_TESTS 1)
endif()
# @/
```

See [the Catch2 CMake integration documentation](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#top) for more detail.

## CMake Enabled Libraries

Boost PFR and Boost MP11 are required by the concepts library, and consequently
by any bindings or components that make use of it. Several other components
make use of specific libraries, such as liblo and `Trill-Arduino`; these are
also included as submodules, and some may be required to build the default test
suite. Since these other dependencies do not provide cmake support, they are
handled on a case by case basis in the `CMakeLists.txt` files of the components
that use them.

```cmake
# @='include cmake libraries'
add_subdirectory(dependencies/pfr)
add_subdirectory(dependencies/mp11)
# @/
```

## Software Components

The project is physically structured as self-contained software components, in
the sense described by John Lakos \cite lakos2019large-scale-cpp. Each
component lives in its own directory, with its own CMakeLists.txt file. The
main list file's main job is to include these components as subdirectories.

```cmake
# @='add subdirectories'
add_library(sygaldry INTERFACE)

add_library(sygaldry-utilities INTERFACE)
    add_subdirectory(sygaldry/utilities/consteval)
target_link_libraries(sygaldry INTERFACE sygaldry-utilities)

add_library(sygaldry-concepts INTERFACE)
    add_subdirectory(sygaldry/concepts/components)
    add_subdirectory(sygaldry/concepts/endpoints)
    add_subdirectory(sygaldry/concepts/functions)
    add_subdirectory(sygaldry/concepts/metadata)
    add_subdirectory(sygaldry/concepts/mimu)
    add_subdirectory(sygaldry/concepts/runtime)
target_link_libraries(sygaldry INTERFACE sygaldry-concepts)

add_library(sygaldry-helpers INTERFACE)
    add_subdirectory(sygaldry/helpers/endpoints)
    add_subdirectory(sygaldry/helpers/metadata)
    add_subdirectory(sygaldry/helpers/mimu)
target_link_libraries(sygaldry INTERFACE sygaldry-helpers)

add_library(sygaldry-components INTERFACE)

    add_library(sygaldry-sensors INTERFACE)

        add_library(sygaldry-sensors-portable INTERFACE)
            # arduino-hack, alphabetically missing here, is added only where required by a platform
            add_subdirectory(sygaldry/sensors/portable/button)
        target_link_libraries(sygaldry-sensors INTERFACE sygaldry-sensors-portable)

        if (ESP_PLATFORM)
            add_library(sygaldry-sensors-esp32 INTERFACE)
            add_library(sygaldry-sensors-arduino INTERFACE)
                add_subdirectory(sygaldry/sensors/portable/arduino-hack)
                add_subdirectory(sygaldry/sensors/esp32/arduino-hack)
                add_subdirectory(sygaldry/sensors/arduino/two_wire)
                add_subdirectory(sygaldry/sensors/arduino/trill_craft)
                add_subdirectory(sygaldry/sensors/esp32/button)
                add_subdirectory(sygaldry/sensors/esp32/gpio)
                    #add_subdirectory(sygaldry/sensors/esp32/icm20948)
                add_subdirectory(sygaldry/sensors/esp32/trill)
            target_link_libraries(sygaldry-sensors INTERFACE sygaldry-sensors-esp32)
            target_link_libraries(sygaldry-sensors INTERFACE sygaldry-sensors-arduino)
        endif()

    target_link_libraries(sygaldry-components INTERFACE sygaldry-sensors)

    add_library(sygaldry-bindings INTERFACE)

        add_library(sygaldry-bindings-portable INTERFACE)
            add_subdirectory(sygaldry/bindings/portable/basic_reader/cstdio_reader)
            add_subdirectory(sygaldry/bindings/portable/cli)
            add_subdirectory(sygaldry/bindings/portable/osc/liblo)
            add_subdirectory(sygaldry/bindings/portable/osc/match_pattern)
            add_subdirectory(sygaldry/bindings/portable/osc/string_constants)
            add_subdirectory(sygaldry/bindings/portable/output_logger)
            add_subdirectory(sygaldry/bindings/portable/rapidjson)
            add_subdirectory(sygaldry/bindings/portable/session_data)
            add_subdirectory(sygaldry/bindings/portable/spelling)
            if (SYGALDRY_BUILD_TESTS)
                add_subdirectory(sygaldry/bindings/portable/basic_reader/test_reader)
                add_subdirectory(sygaldry/bindings/portable/test_component)
            endif()
        target_link_libraries(sygaldry-bindings INTERFACE sygaldry-bindings-portable)

        if (ESP_PLATFORM)
            add_library(sygaldry-bindings-esp32 INTERFACE)
                add_subdirectory(sygaldry/bindings/esp32/libmapper-arduino)
                add_subdirectory(sygaldry/bindings/esp32/spiffs)
                add_subdirectory(sygaldry/bindings/esp32/wifi)
            target_link_libraries(sygaldry-bindings INTERFACE sygaldry-bindings-esp32)
        endif()

    target_link_libraries(sygaldry-components INTERFACE sygaldry-bindings)

    add_library(sygaldry-utility_components INTERFACE)

        add_subdirectory(sygaldry/utility_components/portable/basic_logger/basic_logger)
        if (SYGALDRY_BUILD_TESTS)
            add_subdirectory(sygaldry/utility_components/portable/basic_logger/test_logger)
        endif()
        add_subdirectory(sygaldry/utility_components/portable/basic_logger/cstdio_logger)

    target_link_libraries(sygaldry-components INTERFACE sygaldry-utility_components)

target_link_libraries(sygaldry INTERFACE sygaldry-components)
# @/
```

# Summary

```cmake
# @#'CMakeLists.txt'
# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

cmake_minimum_required(VERSION 3.26)
project(Sygaldry)

@{set SYGALDRY_ROOT}
@{set language standard}

@{prepare for tests}

@{include cmake libraries}

@{add subdirectories}
# @/
```
