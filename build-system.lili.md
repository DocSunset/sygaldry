\page page-build_system The Build System

Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music
Interaction Laboratory (IDMIL), Centre for Interdisciplinary Research in Music
Media and Technology (CIRMMT), McGill University, Montréal, Canada, and Univ.
Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

SPDX-License-Identifier: MIT

[TOC]

# Build Requirements

A full build requires the following executables:

- lili (the literate programming tool used for the project)
- posix utilities (used in convenience shell scripts)
- gnu parallel (ditto)
- cmake
- doxygen (optional)
- the compiler toolchain for the platform the build targets

If you encounter other prerequisites not described above, please open an issue.

# Docker Environment

A Dockerfile is provided that enables Linux users to quickly set up a
consistent development environment. This workflow is still a work in progress
and may be removed in the future if it turns out no one is interested in using
it.

Unfortunately, USB forwarding is not supported by Docker on macOS and Windows,
so this environment is limited on those platforms to compiling and running
tests. Native tools specific to each platform must be used to e.g. upload
firmware to devices.

WARNING: Note that, as it is currently implemented, this container doesn't have
any persistent data! So if you edit the repository within the container and
don't commit and push those changes to a remote, then they will be lost should
you shut down the container. You will also have to authenticate with Github
every time you restart the container. We are open to suggestions for improving
the Docker workflow.

```dockerfile
# @#'Dockerfile'
FROM archlinux:base-devel
RUN pacman -Syu --noconfirm
RUN pacman -S parallel git github-cli cmake vi vim kakoune emacs nano --noconfirm
RUN git clone https://github.com/DocSunset/lili.git
RUN cd lili && make && sudo make install
RUN rm -rf lili
# docker image build -t sygaldry .
# # change the argument to the `--device` flag to your serial port
# docker run --interactive --tty --device=/dev/ttyUSB0 sygaldry 
# gh auth login
# gh repo clone DocSunset/sygaldry -- --recurse-submodules
# @/
```

# Convenience Scripts

## Literate Sources

Literate programming is employed throughout the project. The literate sources
are considered authoritative, and are used to generate most other source files,
including many CMakeLists.txt files.

The following shell script can regenerate all machine sources from the lili
literate source files, and it (or something equivalent) should be run before
every build.

In addition, if `lili` is not already installed, the script will attempt to
install it.

For each `.lili.md` file found in the repository with `find`, the script finds
the first file generated by that literate source, and if the source is more
recently modified than the generated file, reruns `lili` to regenerate all
files derived from that literate source. GNU `parallel` is used to perform this
subroutine for all literate sources. The command exits with a failure code in
case any invocation of `lili` fails, which is used to short-circuit execution
of later shell scripts.

Run this script from the root of the repository.

```sh
# @#'sh/lili.sh'
#!/bin/sh -e
# generate machine sources from literate source code

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

find -iname '*.lili.md' | parallel '
    cd {//}
    generated="$(grep -m 1 -h -r -I "@@#" {/} | head -n 1 | sed 's/^.*@#.//' | sed 's/.$//')"
    [ "$generated" ] && [ {/} -nt "$generated" ] &&
    {
        echo {} "newer than $generated, running lili..."
        lili {/} || exit 1 # short circuit on any lili error with failure return code
    } || exit 0
'
# @/
```

### ccache

One limitation of this current approach to literate tangle synchronisation is
that, if any file generated by a given literate source document is changed,
then all files generated by that literate source are regenerated. This poorly
impacts incremental builds, sometimes causing unnecessary recompilation of
machine sources that have not actually changed due to their updated access
times. It is recommended to use [`ccache`](https://ccache.dev/) to work around
this issue, and generally speed up build times.

## Doxygen

In addition to the literate sources, which are intended to document the
implementation and design rationale of the project, public API's are also
documented using Doxygen special comment blocks, and pretty documentation is
generated with Doxygen and Doxygen Awesome CSS. The order in which files are
presented in the generated documentation is controlled by manually specifying
each file as a subpage in [the implementation guide](\ref docs-implementation).
Documentation can be generated e.g. by running `doxygen` in the root of the
repository, or using the `run.sh _build_doxygen` script, which will build both
the html and pdf documentation.

## Building

A simple shell script is provided to run the compiler and test suite, or
generate documentation, useful for development. Run it from the root of the
project passing the name of the build directory as first argument. The
directories `_build_debug`, `_build_release`, and `_build_doxygen` are
accounted for and included in `.gitignore`.

```sh
# @#'sh/run.sh'
#!/bin/sh -e

# create the build directory if necessary, then build and test the project

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

./sh/lili.sh || exit 1
[ "$#" -gt 0 ] && dir="$1" || dir='_build_debug'
[ "$dir" = "_build_doxygen" ] && exec sh -c 'doxygen && cd _build_doxygen/latex && make pdf'
[ -d "$dir" ] || {
    [ "$dir" == "_build_release" ] && mode=RelWithDebInfo ||
    [ "$dir" == "_build_debug" ]   && mode=Debug ||
    [ -n "$2" ] && mode="$2" ||
    echo "Using default build mode: Debug" && mode=Debug
    CMAKE_BUILD_TYPE="$mode" cmake -B "$dir" -S .
}
cmake --build "$dir" &&
{
    ctest --test-dir "$dir" -R '.*sygaldry.*' ||
        ctest --test-dir "$dir" --rerun-failed --output-on-failure
}
# @/
```

### Building with Clang

Assuming you are building on a machine where `gcc` is the default compiler, you
may wish to compile using `clang` e.g. in order to check for compiler-specific
incompatibilities. You may be able to accomplish this using environment
variables when generating the build directory:

```sh
CC=/usr/bin/clang CXX=/usr/bin/clang++ cmake -D_CMAKE_TOOLCHAIN_PREFIX=llvm -B _build_clang -S .
```

Presumably a similar tactic could be used to compile using `gcc` on a machine where
`clang` is the default, but this hasn't been tested.

## Platform Specific

### ESP32

Building an ESP32 instrument is currently achieved using the normal ESP-IDF
build tools, with the caveat that the argument `-D SYGALDRY_ROOT="..."` must be
passed to `idf.py`, giving the directory in which the root of the Sygaldry
repository is located. For example, the following POSIX shell script, when run
from the root of the repository, would run `idf.py` for the ESP32 instrument
located in the directory passed as the first argument to the script using the
command passed as second argument to the script. Make sure to source the idf
environment exports first.

```sh
# @#'sh/idf.sh'
#!/bin/sh -e

# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music
# Interaction Laboratory (IDMIL), Centre for Interdisciplinary Research in Music
# Media and Technology (CIRMMT), McGill University, Montréal, Canada, and Univ.
# Lille, Inria, CNRS, Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

./sh/lili.sh || exit 1

cd "sygaldry-instruments/$1"
shift
idf.py $@@
# @/
```

Previously, the CMake `ExternalProject_Add` command was used to incorporate
the ESP32 instruments into the usual build process. However, this resulted
in long compilation times during development, even when the ESP32 targets
were not being tested. The current approach requires more manual intervention
from the developer, but is hoped to save time overall.

At the time of writing, Sygaldry also requires a fairly recent version of the
ESP-IDF; an appropriate version of the framework is included as a submodule,
and should be used when installing and exporting the IDF, before running the
above script or its equivalent on your machine.

ESP-IDF projects should add Sygaldry with e.g. the following lines:

```cmake
# idf_component_register( ... ) etc.
add_subdirectory(${SYGALDRY_ROOT} sygbuild)
target_link_libraries(${COMPONENT_LIB} PRIVATE sygaldry)
```

# The CMakeLists.txt

## Sygaldry root

We set a variable allowing components to reach the root of the repository. This
is mainly done so that components can reach the `dependencies` directory
unambiguously as `${SYGALDRY_ROOT}/dependencies`, rather than using a relative
path that might break if the component is physically moved.

```cmake
# @='set SYGALDRY_ROOT'
set(SYGALDRY_ROOT ${CMAKE_CURRENT_LIST_DIR})
# @/
```

## Language Standard

We require C++20 without extensions.

```cmake
# @='set language standard'
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED On)
set(CMAKE_CXX_EXTENSIONS Off)
# @/
```

Each of the project's main package groups is declared as a cmake interface
library. The top level package group then links to each of the package
interface libraries so that clients can link to the whole project if that
is convenient. The list file is structured so that the components included
in a given package group are added with `add_subdirectory` in an indented
block that begins when the library is declared, and ends when it is linked
into its parent package group.

## Testing Framework

Catch2 is used for unit testing on platforms where it can run. Other platforms
may use a different testing methodology.

```cmake
# @='Fetch Catch2'
Include(FetchContent)

FetchContent_Declare(
  Catch2
  GIT_REPOSITORY https://github.com/catchorg/Catch2.git
  GIT_TAG        v3.3.2 # or a later release
)

FetchContent_MakeAvailable(Catch2)
# @/

# @='Include automatic test registration'
list(APPEND CMAKE_MODULE_PATH ${catch2_SOURCE_DIR}/extras)
include(CTest)
include(Catch)
# @/
```

Catch2 is not a good testing framework for ESP32, so the code to enable it
is disabled for that platform.

```cmake
# @='prepare for tests'
if (NOT ESP_PLATFORM)
@{Fetch Catch2}
@{Include automatic test registration}
set(SYGALDRY_BUILD_TESTS 1)
endif()
# @/
```

See [the Catch2 CMake integration documentation](https://github.com/catchorg/Catch2/blob/devel/docs/cmake-integration.md#top) for more detail.

## CMake Enabled Libraries

Boost PFR and Boost MP11 are required by the concepts library, and consequently
by any bindings or components that make use of it. Several other components
make use of specific libraries, such as liblo and `Trill-Arduino`; these are
also included as submodules, and some may be required to build the default test
suite. Since these other dependencies do not provide cmake support, they are
handled on a case by case basis in the `CMakeLists.txt` files of the components
that use them.

```cmake
# @='include cmake libraries'
add_subdirectory(dependencies/pfr)
add_subdirectory(dependencies/mp11)
set(EIGEN_BUILD_TESTING FALSE)
add_subdirectory(dependencies/eigen)
# @/
```

## Software Components

The project is physically structured as self-contained software components, in
the sense described by John Lakos \cite lakos2019large-scale-cpp. Each
component lives in its own directory, with its own CMakeLists.txt file. The
main list file's main job is to include these components as subdirectories.

In an earlier version of the project, there was a directory structure resembing
the following, where each leaf node was a directory containing a component as
just described:

```
sygaldry
├── bindings
│   ├── esp32
│   │   ├── libmapper-arduino
│   │   ├── spiffs
│   │   └── etc.
│   └── portable
│       ├── cli
│       ├── output_logger
│       └── etc.
├── concepts
│   ├── components
│   ├── endpoints
│   └── etc.
├── helpers
│   ├── endpoints
│   ├── metadata
│   └── etc.
└── sensors
    ├── arduino
    │   ├── icm20948
    │   ├── trill_craft
    │   └── etc.
    ├── esp32
    │   ├── adc
    │   ├── arduino-hack
    │   └── etc.
    └── portable
        └── etc.
```

Components were correspondingly named e.g. `sygse-adc`.

As well as being troublingly verbose when editing, this proved problematic when
building on Windows, which at the time in the year 2023 enforced a limit of 260
characters on the length of a path when making a directory. Some instrument
firmwares being built at the time would include the main repository root as a
library, resulting in very long build artefact paths such as
`C:\Users\user\Github\sygaldry\sygaldry\instruments\instrument_name\instrument_name_platform\instrument\build\main\sygbuild\C_Users\user\Github\sygaldry\sensors\arduino\trill_craft\sygaldry-sensors-arduino-trill_craft.obj.d`
that would eventually trip the path length limit. Although it was possible to
modify registry keys and otherwise work around the issue, given the
inconvenience entailed in editing and maintaining the long component names, it
was decided to adopt an organizational scheme with better characteristics in
terms of brevity.

The repository now contains two main content directories: `sygaldry` and
`instruments`. The `sygaldry` directory contains all of the software components
in the library, except for the instruments, which are unsurprisingly found in
the other directory. Rather than being named verbosely, in keeping with \cite
lakos2019large-scale-cpp, packages and their components are given identifiers
of the form `sygXY` where `XY` is the package identifier, with `X` typically
(currently always) referring to the broad type of components and `Y` to the
platform.

```cmake
# @='add subdirectories'
add_library(sygaldry INTERFACE)

add_library(sygac INTERFACE)
                add_subdirectory(sygaldry/sygac-components)
    target_link_libraries(sygac INTERFACE sygac-components)
                add_subdirectory(sygaldry/sygac-endpoints)
    target_link_libraries(sygac INTERFACE sygac-endpoints)
                add_subdirectory(sygaldry/sygac-functions)
    target_link_libraries(sygac INTERFACE sygac-functions)
                add_subdirectory(sygaldry/sygac-metadata)
    target_link_libraries(sygac INTERFACE sygac-metadata)
                add_subdirectory(sygaldry/sygac-mimu)
    target_link_libraries(sygac INTERFACE sygac-mimu)
                add_subdirectory(sygaldry/sygac-runtime)
    target_link_libraries(sygac INTERFACE sygac-runtime)
target_link_libraries(sygaldry INTERFACE sygac)

add_library(sygah INTERFACE)
                add_subdirectory(sygaldry/sygah-consteval)
    target_link_libraries(sygah INTERFACE sygah-consteval)
                add_subdirectory(sygaldry/sygah-endpoints)
    target_link_libraries(sygah INTERFACE sygah-endpoints)
                add_subdirectory(sygaldry/sygah-string_literal)
    target_link_libraries(sygah INTERFACE sygah-string_literal)
                add_subdirectory(sygaldry/sygah-metadata)
    target_link_libraries(sygah INTERFACE sygah-metadata)
                add_subdirectory(sygaldry/sygah-mimu)
    target_link_libraries(sygah INTERFACE sygah-mimu)
target_link_libraries(sygaldry INTERFACE sygah)

add_library(sygsp INTERFACE)
    # arduino-hack, alphabetically missing here, is added only where required by a platform
                add_subdirectory(sygaldry/sygsp-button)
    target_link_libraries(sygsp INTERFACE sygsp-button)
                add_subdirectory(sygaldry/sygsp-delay)
    target_link_libraries(sygsp INTERFACE sygsp-delay)
                add_subdirectory(sygaldry/sygsp-micros)
    target_link_libraries(sygsp INTERFACE sygsp-micros)
                add_subdirectory(sygaldry/sygsp-mimu_units)
    target_link_libraries(sygsp INTERFACE sygsp-mimu_units)
                add_subdirectory(sygaldry/sygsp-complementary_mimu_fusion)
    target_link_libraries(sygsp INTERFACE sygsp-complementary_mimu_fusion)
target_link_libraries(sygaldry INTERFACE sygsp)

if (ESP_PLATFORM)
    add_library(sygse INTERFACE)
    add_library(sygsa INTERFACE)
                    add_subdirectory(sygaldry/sygsp-arduino_hack)
        target_link_libraries(sygsp INTERFACE sygsp-arduino_hack)
                    add_subdirectory(sygaldry/sygse-arduino_hack)
        target_link_libraries(sygse INTERFACE sygse-arduino_hack)
                    add_subdirectory(sygaldry/sygsa-two_wire)
        target_link_libraries(sygsa INTERFACE sygsa-two_wire)
                    add_subdirectory(sygaldry/sygsa-trill_craft)
        target_link_libraries(sygsa INTERFACE sygsa-trill_craft)
                    add_subdirectory(sygaldry/sygse-delay)
        target_link_libraries(sygsa INTERFACE sygse-delay)
                    add_subdirectory(sygaldry/sygse-micros)
        target_link_libraries(sygsa INTERFACE sygse-micros)
                    add_subdirectory(sygaldry/sygse-adc)
        target_link_libraries(sygse INTERFACE sygse-adc)
                    add_subdirectory(sygaldry/sygse-button)
        target_link_libraries(sygse INTERFACE sygse-button)
                    add_subdirectory(sygaldry/sygse-gpio)
        target_link_libraries(sygse INTERFACE sygse-gpio)
                    add_subdirectory(sygaldry/sygsp-icm20948)
        target_link_libraries(sygse INTERFACE sygsp-icm20948)
                    add_subdirectory(sygaldry/sygse-trill)
        target_link_libraries(sygse INTERFACE sygse-trill)
    target_link_libraries(sygaldry INTERFACE sygse)
    target_link_libraries(sygaldry INTERFACE sygsa)
endif()

add_library(sygbp INTERFACE)
                add_subdirectory(sygaldry/sygbp-cstdio_reader)
    target_link_libraries(sygbp INTERFACE sygbp-cstdio_reader)
                add_subdirectory(sygaldry/sygbp-cli)
    target_link_libraries(sygbp INTERFACE sygbp-cli)
                add_subdirectory(sygaldry/sygbp-liblo)
    target_link_libraries(sygbp INTERFACE sygbp-liblo)
                add_subdirectory(sygaldry/sygbp-osc_match_pattern)
    target_link_libraries(sygbp INTERFACE sygbp-osc_match_pattern)
                add_subdirectory(sygaldry/sygbp-osc_string_constants)
    target_link_libraries(sygbp INTERFACE sygbp-osc_string_constants)
                add_subdirectory(sygaldry/sygbp-output_logger)
    target_link_libraries(sygbp INTERFACE sygbp-output_logger)
                add_subdirectory(sygaldry/sygbp-rapid_json)
    target_link_libraries(sygbp INTERFACE sygbp-rapid_json)
                add_subdirectory(sygaldry/sygbp-session_data)
    target_link_libraries(sygbp INTERFACE sygbp-session_data)
                add_subdirectory(sygaldry/sygbp-spelling)
    target_link_libraries(sygbp INTERFACE sygbp-spelling)
    if (SYGALDRY_BUILD_TESTS)
                    add_subdirectory(sygaldry/sygbp-test_reader)
        target_link_libraries(sygbp INTERFACE sygbp-test_reader)
                    add_subdirectory(sygaldry/sygbp-test_component)
        target_link_libraries(sygbp INTERFACE sygbp-test_component)
    endif()
target_link_libraries(sygaldry INTERFACE sygbp)

if (ESP_PLATFORM)
add_library(sygbe INTERFACE)

                add_subdirectory(sygaldry/sygbe-libmapper_arduino)
    target_link_libraries(sygbe INTERFACE sygbe-libmapper_arduino)
                add_subdirectory(sygaldry/sygbe-spiffs)
    target_link_libraries(sygbe INTERFACE sygbe-spiffs)
                add_subdirectory(sygaldry/sygbe-wifi)
    target_link_libraries(sygbe INTERFACE sygbe-wifi)

target_link_libraries(sygaldry INTERFACE sygbe)
endif()

add_library(sygup INTERFACE)

                add_subdirectory(sygaldry/sygup-basic_logger)
    target_link_libraries(sygup INTERFACE sygup-basic_logger)
                add_subdirectory(sygaldry/sygup-cstdio_logger)
    target_link_libraries(sygup INTERFACE sygup-cstdio_logger)
    if (SYGALDRY_BUILD_TESTS)
                    add_subdirectory(sygaldry/sygup-test_logger)
        target_link_libraries(sygup INTERFACE sygup-test_logger)
    endif()

target_link_libraries(sygaldry INTERFACE sygup)

add_subdirectory(sygaldry-instruments/test)
# @/
```

# Summary

```cmake
# @#'CMakeLists.txt'
# Copyright 2023 Travis J. West, https://traviswest.ca, Input Devices and Music Interaction Laboratory
# (IDMIL), Centre for Interdisciplinary Research in Music Media and Technology
# (CIRMMT), McGill University, Montréal, Canada, and Univ. Lille, Inria, CNRS,
# Centrale Lille, UMR 9189 CRIStAL, F-59000 Lille, France

# SPDX-License-Identifier: MIT

cmake_minimum_required(VERSION 3.24)
project(Sygaldry)

@{set SYGALDRY_ROOT}
@{set language standard}

@{prepare for tests}

@{include cmake libraries}

@{add subdirectories}
# @/
```
